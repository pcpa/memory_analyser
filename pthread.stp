#!/usr/bin/stap

/* Sample usage:

$ stap pthread.stp -DDMAXMAPENTRIES=65536 -DMAXACTION=65536 -Gverbose=1 -c 'java -jar /path/to/sample.jar'
Stap ready.
...
Report for java ("/usr/bin/java", ["java", "-jar", ...]
tid to pthread
    729938 0x7f1d3ac006c0 
    729939 0x7f1d3adb26c0 
    729940 0x7f1d24fff6c0 GC Thread#0
    729941 0x7f1d24efe6c0 G1 Main Marker
    729942 0x7f1d24dfd6c0 G1 Conc#0
    729943 0x7f1d081ff6c0 G1 Refine#0
    729944 0x7f1cf4bff6c0 G1 Service
    729945 0x7f1cf4afe6c0 VM Periodic Tas
    729946 0x7f1cf49376c0 VM Thread
    729947 0x7f1cf48366c0 Reference Handl
    729948 0x7f1cf47366c0 Finalizer
    729949 0x7f1cf46366c0 Signal Dispatch
    729950 0x7f1cf45366c0 Service Thread
    729951 0x7f1cf44366c0 Monitor Deflati
    729952 0x7f1cf43366c0 C2 CompilerThre
    729953 0x7f1cf42366c0 C1 CompilerThre
    729954 0x7f1ceffff6c0 Notification Th
    729955 0x7f1cefeff6c0 Common-Cleaner
    729956 0x7f1cefdff6c0 C1 CompilerThre
    729957 0x7f1cefcff6c0 Sync Timer Thre
    729958 0x7f1cefbff6c0 XToolkt-Shutdow
    729959 0x7f1cefaff6c0 Java2D Disposer
    729960 0x7f1cefbff6c0 XToolkt-Shutdow
    729961 0x7f1cefaff6c0 Java2D Disposer
    729962 0x7f1cef8c16c0 AWT-XAWT
    729963 0x7f1cef7c16c0 AWT-Shutdown
    729964 0x7f1cef6c16c0 Timer-0
    729965 0x7f1cefaff6c0 Java2D Disposer
    729966 0x7f1cef8c16c0 AWT-XAWT
    729967 0x7f1cef7c16c0 AWT-Shutdown
    729968 0x7f1cef1556c0 AWT-EventQueue-
    729969 0x7f1cef0556c0 Image Fetcher 3
    729970 0x7f1ceef556c0 Logging-Cleaner
    729972 0x7f1cef0556c0 Image Fetcher 3
    729975 0x7f1cefcff6c0 Sync Timer Thre
    729976 0x7f1cefbff6c0 XToolkt-Shutdow
    729977 0x7f1ceef556c0 Logging-Cleaner
    729978 0x7f1d3aeb26c0 pool-1-thread-1
mutex 0x7f1d3c595c60 locked 90810 times by 23 threads
    total contention	: 1 sec, 112 msecs and 112574 usecs
    min contention	: 1 usec
    max contention	: 954 usecs
    average contention	: 12 usecs
    total lock		: 780683 usecs
    min lock		: 2 usecs
    max lock		: 2928 usecs
    average lock	: 8 usecs
mutex 0x7f1d2011d8e8 locked 117537 times by 18 threads
    total contention	: 418145 usecs
    min contention	: 1 usec
    max contention	: 153 usecs
    average contention	: 3 usecs
    total lock		: 613125 usecs
    min lock		: 2 usecs
    max lock		: 236 usecs
    average lock	: 5 usecs
mutex 0x7f1d3c571828 locked 45645 times by 7 threads
    total contention	: 152136 usecs
    min contention	: 1 usec
    max contention	: 112 usecs
    average contention	: 3 usecs
    total lock		: 227895 usecs
    min lock		: 2 usecs
    max lock		: 146 usecs
    average lock	: 4 usecs
mutex 0x7f1d3c56f728 locked 37512 times by 21 threads, 49 failed locks
    total contention	: 117372 usecs
    min contention	: 1 usec
    max contention	: 100 usecs
    average contention	: 3 usecs
    total lock		: 229186 usecs
    min lock		: 2 usecs
    max lock		: 143 usecs
    average lock	: 6 usecs
mutex 0x7f1d3c56ff28 locked 30236 times by 21 threads
    total contention	: 115713 usecs
    min contention	: 1 usec
    max contention	: 150 usecs
    average contention	: 3 usecs
    total lock		: 299412 usecs
    min lock		: 2 usecs
    max lock		: 368 usecs
    average lock	: 9 usecs
mutex 0x7f1d3c56fea8 locked 24902 times by 23 threads
    total contention	: 85642 usecs
    min contention	: 1 usec
    max contention	: 101 usecs
    average contention	: 3 usecs
    total lock		: 129140 usecs
    min lock		: 2 usecs
    max lock		: 181 usecs
    average lock	: 5 usecs
mutex 0x7f1d3c5711a8 locked 11044 times by 18 threads
    total contention	: 81464 usecs
    min contention	: 1 usec
    max contention	: 456 usecs
    average contention	: 7 usecs
    total lock		: 101871 usecs
    min lock		: 2 usecs
    max lock		: 156 usecs
    average lock	: 9 usecs
mutex 0x7f1d201655d8 locked 23882 times by 5 threads
    total contention	: 76406 usecs
    min contention	: 1 usec
    max contention	: 155 usecs
    average contention	: 3 usecs
    total lock		: 116617 usecs
    min lock		: 2 usecs
    max lock		: 347 usecs
    average lock	: 4 usecs
mutex 0x7f1d3c56fda8 locked 12147 times by 23 threads, 364 failed locks
    total contention	: 67292 usecs
    min contention	: 1 usec
    max contention	: 257 usecs
    average contention	: 5 usecs
    total lock		: 444117 usecs
    min lock		: 2 usecs
    max lock		: 505 usecs
    average lock	: 36 usecs
mutex 0x7f1d3c56f7a8 locked 16915 times by 18 threads, 33 failed locks
    total contention	: 61479 usecs
    min contention	: 1 usec
    max contention	: 509 usecs
    average contention	: 3 usecs
    total lock		: 92933 usecs
    min lock		: 2 usecs
    max lock		: 124 usecs
    average lock	: 5 usecs
initialized mutex 0x7f1d3c56fd28 locked for 8 secs, 973 msecs and 973993 usecs by tid 729947
    tid 729939 waiting for 6 secs, 141 msecs and 141258 usecs
    tid 729968 waiting for 197852 usecs
    tid 729977 waiting for 209899 usecs
initialized mutex 0x7f1d20155f28 locked for 8 secs, 973 msecs and 973928 usecs by tid 729948
initialized mutex 0x7f1d3c571d28 locked for 8 secs, 971 msecs and 971523 usecs by tid 729951
initialized mutex 0x7f1d3c571c28 locked for 8 secs, 946 msecs and 946303 usecs by tid 729954
initialized mutex 0x7f1d2016e940 locked for 8 secs, 938 msecs and 938116 usecs by tid 729955
initialized mutex 0x7f1d20492980 locked for 5 secs, 355 msecs and 355743 usecs by tid 729965
initialized mutex 0x7f1d3c56fe28 locked for 4 secs, 937 msecs and 937701 usecs by tid 729939
    tid 729946 waiting for 197767 usecs
    tid 729960 waiting for 2 secs, 317 msecs and 317141 usecs
    tid 729957 waiting for 2 secs, 309 msecs and 309423 usecs
    tid 729970 waiting for 3 secs, 996 msecs and 996821 usecs
    tid 729969 waiting for 3 secs, 923 msecs and 923610 usecs
    tid 729968 waiting for 210225 usecs
    tid 729964 waiting for 210007 usecs
    tid 729977 waiting for 208692 usecs
    tid 729976 waiting for 200549 usecs
    tid 729975 waiting for 199589 usecs
    tid 729978 waiting for 198603 usecs
    tid 729949 waiting for 197737 usecs
initialized mutex 0x7f1c3c0c2e28 locked for 1 sec, 627 msecs and 627554 usecs by tid 729972
    tid 729968 waiting for 1 sec, 636 msecs and 636547 usecs
initialized mutex 0x7f1d3c56fb28 locked for 355654 usecs by tid 729946
    tid 729939 waiting for 5 secs, 448 msecs and 448039 usecs
    tid 729968 waiting for 197845 usecs
initialized mutex 0x7f1c38057828 locked for 213644 usecs by tid 729967
    tid 729968 waiting for 213755 usecs
initialized mutex 0x7f1d3c5712a8 locked for 205855 usecs by tid 729952
    tid 729959 waiting for 8 secs, 841 msecs and 841187 usecs
    tid 729958 waiting for 8 secs, 863 msecs and 863429 usecs
    tid 729963 waiting for 6 secs, 99 msecs and 99236 usecs
    tid 729962 waiting for 6 secs, 182 msecs and 182426 usecs
    tid 729961 waiting for 6 secs, 125 msecs and 125760 usecs
    tid 729939 waiting for 4 secs, 940 msecs and 940317 usecs
    tid 729969 waiting for 4 secs, 29 msecs and 29689 usecs
    tid 729970 waiting for 4 secs, 100 msecs and 100698 usecs
    tid 729960 waiting for 3 secs, 226 msecs and 226093 usecs
    tid 729957 waiting for 3 secs, 224 msecs and 224851 usecs
    tid 729968 waiting for 199633 usecs
    tid 729978 waiting for 201909 usecs
    tid 729953 waiting for 197844 usecs
initialized mutex 0x7f1d3c571ca8 locked for 198468 usecs by tid 729950
    tid 729959 waiting for 8 secs, 739 msecs and 739890 usecs
    tid 729958 waiting for 8 secs, 739 msecs and 739798 usecs
    tid 729946 waiting for 197669 usecs
    tid 729963 waiting for 5 secs, 988 msecs and 988689 usecs
    tid 729962 waiting for 5 secs, 987 msecs and 987603 usecs
    tid 729970 waiting for 3 secs, 996 msecs and 996709 usecs
    tid 729969 waiting for 3 secs, 923 msecs and 923493 usecs
    tid 729960 waiting for 2 secs, 317 msecs and 317098 usecs
    tid 729957 waiting for 2 secs, 309 msecs and 309387 usecs
    tid 729964 waiting for 209203 usecs
    tid 729977 waiting for 208601 usecs
    tid 729976 waiting for 200484 usecs
    tid 729975 waiting for 199543 usecs
    tid 729978 waiting for 198559 usecs
Stap done.
 */

/* -Gtrap_on_all_errors=1 to raise SIGTRAP if any non zero state is returned */
global trap_on_all_errors = 0;
/* -Gtrap_on_XYZ=1 to raise SIGTRAP if related errno is returned; this is a
 * way to globally ignore some errors */
global trap_on_ownerdead = -1;
global trap_on_timedout = -1;
global trap_on_busy = -1;
global trap_on_again = -1;
/* These are for the common/expected cases, of pthread_*_trylock instantly
 * returning when some other thread has the lock, or a lock attempt with
 * a timer that times out. */
global trap_on_expected_busy = 0;
global trap_on_expected_timedout = 0;

global verbose = 0;

global expensive_checks = 0;

/* Number of detailed mutexes to report; sorted by total contention time.
 * This option is added to avoid too large N vale for -DMAX_ACTIONS=N as
 * well as too much noise in output.  */
global report_mutex_count = 10;

/* Number of detailed conditions to report; sorted by total wait time. */
global report_cond_count = 10;

/* Number of detailed read rwlocks to report; sorted by total wait time. */
global report_rdlock_count = 10;
/* Number of detailed write rwlocks to report; sorted by total wait time. */
global report_wrlock_count = 10;

/* Number of detailed spinlocks to report; sorted by total wait time. */
global report_spin_count = 10;

private global tid_to_thread;
private global thread_to_tid;
private global thread_name;
private global mutex_lock;
private global mutex_lock_count;
private global mutex_lock_entry;
private global mutex_lock_entry_timer;
private global mutex_consistent;
private global mutex_prioceiling;
private global mutex_init;

/* Sum of contention time from attempt to lock until getting the lock */
private global mutex_contention_total_time;
/* Minimum wait time to get the lock */
private global mutex_contention_min_time;
/* Maximum wait time to get the lock */
private global mutex_contention_max_time;
/* Number of successful locks */
private global mutex_contention_count;
/* Number of threads that did get the mutex lock */
private global mutex_contention_per_thread;
/* Number of failed trylock calls */
private global mutex_contention_fail_try;
/* Number of failed timedlock calls */
private global mutex_contention_fail_timed;
/* Sum of lock time from lock to unlock */
private global mutex_lock_total_time;
/* Minimum lock time */
private global mutex_lock_min_time;
/* Maximum lock time */
private global mutex_lock_max_time;

private global conditions;
private global mutex_wait;
private global cond_wait;
private global cond_wait_timer;
private global cond_init;

/* Count of successful cond wait calls */
private global cond_wait_count;
/* Count of successful cond wait calls per thread */
private global cond_wait_per_thread;
/* Sum of total time waiting for a condition by all threads */
private global cond_wait_total_time;
/* Minimum time waiting for a condition by all threads */
private global cond_wait_min_time;
/* Maximum time waiting for a condition by all threads */
private global cond_wait_max_time;
/* Number of failed timed_cond_wait */
private global cond_wait_timedout;
private global cond_signal_count;
private global cond_signal_per_thread;
private global cond_broadcast_count;
private global cond_broadcast_per_thread;

private global rwlock_init;
private global rdlock_entry;
private global rdlock_entry_timer;
private global rdlocks;
private global wrlock_entry;
private global wrlock_entry_timer;
private global wrlocks;

private global rdlock_count;
private global rdlock_contention_total_time;
private global rdlock_contention_min_time;
private global rdlock_contention_max_time;
private global rdlock_contention_count;
private global rdlock_contention_per_thread;
private global rdlock_contention_fail_try;
private global rdlock_contention_fail_timed;
private global rdlock_total_time;
private global rdlock_min_time;
private global rdlock_max_time;
private global wrlock_count;
private global wrlock_contention_total_time;
private global wrlock_contention_min_time;
private global wrlock_contention_max_time;
private global wrlock_contention_count;
private global wrlock_contention_per_thread;
private global wrlock_contention_fail_try;
private global wrlock_contention_fail_timed;
private global wrlock_total_time;
private global wrlock_min_time;
private global wrlock_max_time;

private global spin_init;
private global spin_entry;
private global spinlocks;

private global spin_count;
private global spin_contention_total_time;
private global spin_contention_min_time;
private global spin_contention_max_time;
private global spin_contention_count;
private global spin_contention_per_thread;
private global spin_contention_fail_try;
private global spin_total_time;
private global spin_min_time;
private global spin_max_time;

global process_name = "";
global process_arguments, exec_process_arguments;

private global details;
private global details_thread_count;
private global details_signal_count;
private global details_broadcast_count;

@define	EPERM			%(   1 %)
@define EAGAIN			%(  11 %)
@define	EBUSY			%(  16 %)
@define EINVAL			%(  22 %)
@define	EDEADLK			%(  35 %)
@define EOPNOTSUPP		%(  95 %)
@define	ETIMEDOUT		%( 110 %)
@define	EOWNERDEAD		%( 130 %)
@define	ENOTRECOVERABLE		%( 131 %)

private global _arg1;
private global _arg2;
private global _arg3;
private global _return;
@define ARG1			%( @defined($arg1) ? $arg1 : register(_arg1) %)
@define ENTRY_ARG1		%( @defined(@entry($arg1)) ? @entry($arg1) : @entry(register(_arg1)) %)
@define ARG2			%( @defined($arg2) ? $arg2 : register(_arg2) %)
@define ENTRY_ARG2		%( @defined(@entry($arg2)) ? @entry($arg2) : @entry(register(_arg2)) %)
@define ARG3			%( @defined($arg3) ? $arg3 : register(_arg3) %)
@define ENTRY_ARG3		%( @defined(@entry($arg3)) ? @entry($arg3) : @entry(register(_arg3)) %)
@define RETURN			%( @defined($return) ? $return : register(_return) %)

probe begin {
    /* No setting to "only" trap on specific error */
    if (trap_on_ownerdead == -1)
	trap_on_ownerdead = trap_on_all_errors;
    if (trap_on_timedout == -1)
	trap_on_timedout = trap_on_all_errors;
    if (trap_on_busy == -1)
	trap_on_busy = trap_on_all_errors;
    if (trap_on_again == -1)
	trap_on_again = trap_on_all_errors;
    %( arch == "x86_64" %?
      _arg1 = "rdi";
      _arg2 = "rsi";
      _arg3 = "rdx";
      _return = "rax"
      %: %( arch == "arm64" %?
	   _arg1 = "x0";
	   _arg2 = "x1";
	   _arg3 = "x2";
	   _return = "x0"
	   %: %( arch == "powerpc" %?
		_arg1 = "r3";
		_arg2 = "r4";
		_arg3 = "r5";
		_return = "r3"
		%: error("unsupported architecture")
		%)
	   %)
      %);
    printf("Stap ready.\n");
}

function report_error(where:string, errno:long) {
    if ((errno == @EOWNERDEAD && !trap_on_ownerdead) ||
	(errno == @ETIMEDOUT && !trap_on_timedout) ||
	(errno == @EBUSY && !trap_on_busy) ||
	(errno == @EAGAIN && !trap_on_again) ||
	!errno || !trap_on_all_errors)
	return;
    printf("%s error: %s\n", where, errno_str(errno));
    print_ubacktrace();
    %(guru_mode != 0 %?
      raise(%{ SIGTRAP %}) %: printf("generating SIGTRAP needs guru mode\n")
	  %);
}

probe
process("/lib64/libc.so.6").function("__pthread_create").return !,
process("/lib64/libc.so.6").function("pthread_create").return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	//thread	= @ENTRY_ARG1;
	/*
	attr	= @ENTRY_ARG2;
	routine	= @ENTRY_ARG3;
	arg	= @ENTRY_ARG4;
	 */
	/*
	struct pthread {
	    union {
	        tcbhead_t header;		sizeof(tcbhead_t) = 704
	        void *__padding[24];
	    };
	    list_t list;			sizeof(list_t) = 16
	    pid_t tid;
	    ...
	 }
	 */
	 /* This looks too fragile */
	/*
	pthread = user_int64(thread);
	tid = user_int32(pthread + 720);
	tid_to_thread[tid] = thread;
	*/
    }
    else
	report_error(ppfunc(), result);
}
/* Use "mark" instead of too fragile offset computation as example above. */
probe
process("/lib64/libc.so.6").mark("pthread_start") {
    if (pid() != target())
	next;
    thread	= $arg1;
    /*
    routine	= $arg2;
    arg		= $arg3;
     */
    tid_to_thread[tid()] = thread;
    thread_to_tid[thread] = tid();
}

probe
process("/lib64/libc.so.6").function("__pthread_setname_np").return !,
process("/lib64/libc.so.6").function("pthread_setname_np").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	thread	= @ENTRY_ARG1;
	name	= @ENTRY_ARG2;
	if (verbose)
	    thread_name[thread] = user_string(name);
    }
    else
	report_error(ppfunc(), result);
}

probe
process("/lib64/libc.so.6").function("__pthread_cancel").return !,
process("/lib64/libc.so.6").function("pthread_cancel").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	// thread = @ENTRY_ARG1;
    }
    else
	report_error(ppfunc(), result);
}

/*
probe
process("/lib64/libc.so.6").function("__pthread_testcancel") !,
process("/lib64/libc.so.6").function("pthread_testcancel") {
    if (pid() != target())
	next;
}
 */

probe
process("/lib64/libc.so.6").function("__pthread_detach").return !,
process("/lib64/libc.so.6").function("pthread_detach").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	// thread = @ENTRY_ARG1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process("/lib64/libc.so.6").function("__pthread_exit") !,
process("/lib64/libc.so.6").function("pthread_exit") {
    if (pid() != target())
	next;
    thread = tid_to_thread[tid()];
    delete tid_to_thread[tid()];
    delete thread_to_tid[thread];
    if (verbose)
	delete thread_name[thread];
}

probe
process("/lib64/libc.so.6").function("__pthread_join").return !,
process("/lib64/libc.so.6").function("pthread_join").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	thread = @ENTRY_ARG1;
	tid = thread_to_tid[thread];
	delete tid_to_thread[tid];
	delete thread_to_tid[thread];
	if (verbose)
	    delete thread_name[thread];
    }
    else
	report_error(ppfunc(), result);
}

probe
process("/lib64/libc.so.6").function("__pthread_kill").return !,
process("/lib64/libc.so.6").function("pthread_kill").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	// thread = @ENTRY_ARG1;
	// signal = @ENTRY_ARG2;
    }
    else
	report_error(ppfunc(), result);
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_init").return !,
process("/lib64/libc.so.6").function("pthread_mutex_init").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	mutex = @ENTRY_ARG1;
	/*
	attr  = @ENTRY_ARG2;
	 */
	check_memory_reuse(mutex);
	mutex_init[mutex] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

function common_mutex_lock(mutex, istry, tmout, result) {
    if (result == 0) {
	if ((++mutex_lock_count[mutex]) == 1) {
	    mutex_lock[mutex] = tid();
	    now = gettimeofday_us();
	    if (verbose) {
		diff = now - mutex_lock_entry[tid(), mutex];
		mutex_contention_total_time[mutex] += diff;
		if (!mutex_contention_min_time[mutex] ||
		    mutex_contention_min_time[mutex] > diff)
		    mutex_contention_min_time[mutex] = diff;
		if (mutex_contention_max_time[mutex] < diff)
		    mutex_contention_max_time[mutex] = diff;
		++mutex_contention_count[mutex];
		++mutex_contention_per_thread[tid(), mutex];
	    }
	    mutex_lock_entry[tid(), mutex] = now;
	}
    }
    else {
	report = 1;
	/* EAGAIN is returned if the counter wrapers around */
	if (istry) {
	    if (verbose)
		++mutex_contention_fail_try[mutex];
	    report = !trap_on_expected_busy || result != @EBUSY;
	}
	else if (tmout) {
	    if (verbose)
		++mutex_contention_fail_timed[mutex];
	    report = !trap_on_expected_timedout || result != @ETIMEDOUT;
	    delete mutex_lock_entry_timer[tid(), mutex];
	}
	if (report)
	    report_error(ppfunc(), result);
	delete mutex_lock_entry[tid(), mutex];
    }
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_trylock") !,
process("/lib64/libc.so.6").function("pthread_mutex_trylock") {
    if (pid() != target())
	next;
    mutex = @ARG1;
    mutex_lock_entry[tid(), mutex] = gettimeofday_us();
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_trylock").return !,
process("/lib64/libc.so.6").function("pthread_mutex_trylock").return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    common_mutex_lock(mutex, 1, 0, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_timedlock") !,
process("/lib64/libc.so.6").function("pthread_mutex_timedlock") {
    if (pid() != target())
	next;
    mutex = @ARG1;
    tmout = @ARG2;
    mutex_lock_entry[tid(), mutex] = gettimeofday_us();
    mutex_lock_entry_timer[tid(), mutex] = tmout;
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_timedlock").return !,
process("/lib64/libc.so.6").function("pthread_mutex_timedlock").return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    tmout = @ENTRY_ARG2;
    common_mutex_lock(mutex, 0, tmout, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_lock") !,
process("/lib64/libc.so.6").function("pthread_mutex_lock") {
    if (pid() != target())
	next;
    mutex = @ARG1;
    mutex_lock_entry[tid(), mutex] = gettimeofday_us();
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_lock").return !,
process("/lib64/libc.so.6").function("pthread_mutex_lock").return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    common_mutex_lock(mutex, 0, 0, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_consistent").return !,
process("/lib64/libc.so.6").function("pthread_mutex_consistent").return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    if (result)
	report_error(ppfunc(), result);
    /* Record it is now consistent. Error state is -1. */
    mutex_consistent[mutex] = gettimeofday_us();
}


probe
process("/lib64/libc.so.6").function("__pthread_mutex_getprioceiling").return !,
process("/lib64/libc.so.6").function("pthread_mutex_getprioceiling").return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    ceiling = @ENTRY_ARG2;
    if (result)
	report_error(ppfunc(), result);
    else if (!mutex_prioceiling[mutex])
	mutex_prioceiling[mutex] = user_int32(ceiling);
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_setprioceiling").return !,
process("/lib64/libc.so.6").function("pthread_mutex_setprioceiling").return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    new_ceiling = @ENTRY_ARG2;
    /*
    old_ceiling = @ENTRY_ARG3;
     */
    if (result)
	report_error(ppfunc(), result);
    else
	mutex_prioceiling[mutex] = new_ceiling;
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_unlock").return !,
process("/lib64/libc.so.6").function("pthread_mutex_unlock").return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    if (result)
	report_error(ppfunc(), result);
    else {
	if (--mutex_lock_count[mutex] == 0) {
	    now = gettimeofday_us();
	    if (verbose) {
		diff = now - mutex_lock_entry[tid(), mutex];
		mutex_lock_total_time[mutex] += diff;
		if (!mutex_lock_min_time[mutex] ||
		    mutex_lock_min_time[mutex] > diff)
		    mutex_lock_min_time[mutex] = diff;
		if (mutex_lock_max_time[mutex] < diff)
		    mutex_lock_max_time[mutex] = diff;
	    }
	    /* mutex_lock_count and mutex_lock_per_thread would be basically
	     * the same as mutex_contention_*, not counting pending or active
	     * locks. */
	    delete mutex_lock[mutex];
	    delete mutex_lock_entry[tid(), mutex];
	    delete mutex_lock_entry_timer[tid(), mutex];
	    delete mutex_lock_count[mutex];
	}
    }
}

function
forget_mutex(mutex) {
    delete mutex_lock[mutex];
    if (expensive_checks) {
	foreach ([tid, key] in mutex_lock_entry) {
	    if (key == mutex) {
		delete mutex_lock_entry[tid, mutex];
		delete mutex_lock_entry_timer[tid, mutex];
		break;
	    }
	}
    }
    delete mutex_lock_count[mutex];
    if (verbose) {
	delete mutex_contention_total_time[mutex];
	delete mutex_contention_min_time[mutex];
	delete mutex_contention_max_time[mutex];
	delete mutex_contention_count[mutex];
	foreach ([tid, key] in mutex_contention_per_thread) {
	    if (key == mutex) {
		delete mutex_contention_per_thread[tid, mutex];
		break;
	    }
	}
	delete mutex_contention_fail_try[mutex];
	delete mutex_contention_fail_timed[mutex];
	delete mutex_lock_total_time[mutex];
	delete mutex_lock_min_time[mutex];
	delete mutex_lock_max_time[mutex];
    }
}

probe
process("/lib64/libc.so.6").function("__pthread_mutex_destroy").return !,
process("/lib64/libc.so.6").function("pthread_mutex_destroy").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	mutex = @ENTRY_ARG1;
	/* Use -1 to known it was destroyed */
	mutex_init[mutex] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process("/lib64/libc.so.6").function("__pthread_cond_init").return !,
process("/lib64/libc.so.6").function("pthread_cond_init").return {
    if (pid() != target())
	next;
    result = @RETURN;
    /*
    attr = @ENTRY_ARG2;
     */
    if (result == 0) {
	cond = @ENTRY_ARG1;
	check_memory_reuse(cond);
	cond_init[cond] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

probe
process("/lib64/libc.so.6").function("__pthread_cond_broadcast").return !,
process("/lib64/libc.so.6").function("pthread_cond_broadcast").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	cond = @ENTRY_ARG1;
	if (verbose) {
	    ++cond_broadcast_count[cond];
	    ++cond_broadcast_per_thread[tid(), cond];
	}
    }
    else
	report_error(ppfunc(), result);
}

probe
process("/lib64/libc.so.6").function("___pthread_cond_signal").return !,
process("/lib64/libc.so.6").function("__pthread_cond_signal").return !,
process("/lib64/libc.so.6").function("pthread_cond_signal").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	cond = @ENTRY_ARG1;
	if (verbose) {
	    ++cond_signal_count[cond];
	    ++cond_signal_per_thread[tid(), cond];
	}
    }
    else
	report_error(ppfunc(), result);
}

function
common_cond_wait_call(cond, mutex, tmout) {
    cond_wait[tid(), cond] = gettimeofday_us();
    if (tmout)
	cond_wait_timer[tid(), cond] = tmout;
    if (expensive_checks) {
	foreach ([tid, key] in mutex_wait) {
	    value = mutex_wait[tid, key];
	    if (key == cond && value != mutex) {
		printf("Multiple mutexes used on call to pthead_cond_wait, "
		       " prevously %p and now %p\n", value, mutex);
		print_ubacktrace();
		break;
	    }
	}
    }
    mutex_wait[tid(), cond] = mutex;
}

function
common_cond_wait_return(cond, mutex, tmout, result) {
    report = !!result;
    if (result) {
	if (tmout && result == @ETIMEDOUT) {
	    if (verbose)
		++cond_wait_timedout[cond];
	    report = trap_on_expected_timedout;
	}
	if (report)
	    report_error(ppfunc(), result);
    }
    if (verbose) {
	now = gettimeofday_us();
	diff = now - cond_wait[tid(), cond];
	++cond_wait_count[cond];
	cond_wait_total_time[cond] += diff;
	if (!cond_wait_min_time[cond] || cond_wait_min_time[cond] > diff)
	    cond_wait_min_time[cond] = diff;
	if (cond_wait_max_time[cond] < diff)
	    cond_wait_max_time[cond] = diff;
	if (!report)
	    ++cond_wait_per_thread[tid(), cond];
    }
    delete cond_wait[tid(), cond];
    delete mutex_wait[tid(), cond];
    if (tmout)
	delete cond_wait_timer[tid(), cond];
}

probe
process("/lib64/libc.so.6").function("___pthread_cond_wait") !,
process("/lib64/libc.so.6").function("pthread_cond_wait") {
    if (pid() != target())
	next;
    cond  = @ARG1;
    mutex = @ARG2;
    common_cond_wait_call(cond, mutex, 0);
}

probe
process("/lib64/libc.so.6").function("___pthread_cond_wait").return !,
process("/lib64/libc.so.6").function("pthread_cond_wait").return {
    if (pid() != target())
	next;
    result = @RETURN;
    cond  = @ENTRY_ARG1;
    mutex = @ENTRY_ARG2;
    common_cond_wait_return(cond, mutex, 0, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_cond_timedwait") !,
process("/lib64/libc.so.6").function("pthread_cond_timedwait") {
    if (pid() != target())
	next;
    cond  = @ARG1;
    mutex = @ARG2;
    tmout = @ARG3;
    common_cond_wait_call(cond, mutex, tmout);
}

probe
process("/lib64/libc.so.6").function("__pthread_cond_timedwait").return !,
process("/lib64/libc.so.6").function("pthread_cond_timedwait").return {
    if (pid() != target())
	next;
    result = @RETURN;
    cond  = @ENTRY_ARG1;
    mutex = @ENTRY_ARG2;
    tmout = @ENTRY_ARG3;
    common_cond_wait_return(cond, mutex, tmout, result);
}

function
forget_condition(cond) {
    delete conditions[cond];
    if (expensive_checks) {
	/* These might only hold data on error/debug conditions */
	foreach ([tid, key] in cond_wait) {
	    if (key == cond)
		delete cond_wait[tid, key];
	}
	foreach ([tid, key] in mutex_wait) {
	    if (key == cond)
		delete mutex_wait[tid, key];
	}
	foreach ([tid, key] in cond_wait_timer) {
	    if (key == cond)
		delete cond_wait_timer[tid, key];
	}
    }
    if (verbose) {
	delete cond_broadcast_count[cond];
	foreach ([tid, key] in cond_broadcast_per_thread) {
	    if (key == cond)
		delete cond_broadcast_per_thread[tid, cond];
	}
	delete cond_signal_count[cond];
	foreach ([tid, key] in cond_signal_per_thread) {
	    if (key == cond)
		delete cond_signal_per_thread[tid, cond];
	}
	delete cond_wait_timedout[cond];
	delete cond_wait_count[cond];
	delete cond_wait_total_time[cond];
	delete cond_wait_min_time[cond];
	delete cond_wait_max_time[cond];
	foreach ([tid, key] in cond_wait_per_thread) {
	    if (key == cond)
		delete cond_wait_per_thread[tid, cond];
	}
    }
}

probe
process("/lib64/libc.so.6").function("__pthread_cond_destroy").return !,
process("/lib64/libc.so.6").function("pthread_cond_destroy").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	cond = @ENTRY_ARG1;
	/* Use -1 to known it was destroyed */
	cond_init[cond] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_init").return !,
process("/lib64/libc.so.6").function("pthread_rwlock_init").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	rwlock	= @ENTRY_ARG1;
	/*
	attr	= @ENTRY_ARG2;
	 */
	check_memory_reuse(rwlock);
	rwlock_init[rwlock] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

function common_rdlock(rdlock, istry, tmout, result) {
    if (result == 0) {
	rdlocks[rdlock] = tid();
	now = gettimeofday_us();
	if (verbose) {
	    ++rdlock_count[rdlock];
	    diff = now - rdlock_entry[tid(), rdlock];
	    rdlock_contention_total_time[rdlock] += diff;
	    if (!rdlock_contention_min_time[rdlock] ||
		rdlock_contention_min_time[rdlock] > diff)
		rdlock_contention_min_time[rdlock] = diff;
	    if (rdlock_contention_max_time[rdlock] < diff)
		rdlock_contention_max_time[rdlock] = diff;
	    ++rdlock_contention_count[rdlock];
	    ++rdlock_contention_per_thread[tid(), rdlock];
	}
	rdlock_entry[tid(), rdlock] = now;
    }
    else {
	report = 1;
	if (istry && result == @EBUSY)
	    report = trap_on_expected_busy;
	else if (tmout && result == @ETIMEDOUT) {
	    ++rdlock_contention_fail_timed[rdlock];
	    report = trap_on_expected_timedout;
	}
	if (report)
	    report_error(ppfunc(), result);
	delete rdlock_entry[tid(), rdlock];
	if (tmout)
	    delete rdlock_entry_timer[tid(), rdlock];
    }
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_rdlock") !,
process("/lib64/libc.so.6").function("pthread_rwlock_rdlock") {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    rdlock_entry[tid(), rwlock] = gettimeofday_us();
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_rdlock").return !,
process("/lib64/libc.so.6").function("pthread_rwlock_rdlock").return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    common_rdlock(rwlock, 0, 0, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_tryrdlock") !,
process("/lib64/libc.so.6").function("pthread_rwlock_tryrdlock") {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    rdlock_entry[tid(), rwlock] = gettimeofday_us();
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_tryrdlock").return !,
process("/lib64/libc.so.6").function("pthread_rwlock_tryrdlock").return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    common_rdlock(rwlock, 1, 0, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_timedrdlock") !,
process("/lib64/libc.so.6").function("pthread_rwlock_timedrdlock") {
	if (pid() != target())
	next;
    rwlock	= @ARG1;
    tmout	= @ARG2;
    rdlock_entry[tid(), rwlock] = gettimeofday_us();
    rdlock_entry_timer[tid(), rwlock] = tmout;
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_timedrdlock").return !,
process("/lib64/libc.so.6").function("pthread_rwlock_timedrdlock").return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    tmout	= @ENTRY_ARG2;
    common_rdlock(rwlock, 0, tmout, result);
}

function common_wrlock(wrlock, istry, tmout, result) {
    if (result == 0) {
	wrlocks[wrlock] = tid();
	now = gettimeofday_us();
	if (verbose) {
	    ++wrlock_count[wrlock];
	    diff = now - wrlock_entry[tid(), wrlock];
	    wrlock_contention_total_time[wrlock] += diff;
	    if (!wrlock_contention_min_time[wrlock] ||
		wrlock_contention_min_time[wrlock] > diff)
		wrlock_contention_min_time[wrlock] = diff;
	    if (wrlock_contention_max_time[wrlock] < diff)
		wrlock_contention_max_time[wrlock] = diff;
	    ++wrlock_contention_count[wrlock];
	    ++wrlock_contention_per_thread[tid(), wrlock];
	}
	wrlock_entry[tid(), wrlock] = now;
    }
    else {
	report = 1;
	if (istry && result == @EBUSY)
	    report = trap_on_expected_busy;
	else if (tmout && result == @ETIMEDOUT) {
	    ++wrlock_contention_fail_timed[wrlock];
	    report = trap_on_expected_timedout;
	}
	if (report)
	    report_error(ppfunc(), result);
	delete wrlock_entry[tid(), wrlock];
	if (tmout)
	    delete wrlock_entry_timer[tid(), wrlock];
    }
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_wrlock") !,
process("/lib64/libc.so.6").function("pthread_rwlock_wrlock") {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    wrlock_entry[tid(), rwlock] = gettimeofday_us();
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_wrlock").return !,
process("/lib64/libc.so.6").function("pthread_rwlock_wrlock").return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    common_wrlock(rwlock, 0, 0, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_trywrlock") !,
process("/lib64/libc.so.6").function("pthread_rwlock_trywrlock") {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    wrlock_entry[tid(), rwlock] = gettimeofday_us();
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_trywrlock").return !,
process("/lib64/libc.so.6").function("pthread_rwlock_trywrlock").return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    common_wrlock(rwlock, 1, 0, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_timedwrlock") !,
process("/lib64/libc.so.6").function("pthread_rwlock_timedwrlock") {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    tmout	= @ARG2;
    wrlock_entry[tid(), rwlock] = gettimeofday_us();
    wrlock_entry_timer[tid(), rwlock] = tmout;
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_timedwrlock").return !,
process("/lib64/libc.so.6").function("pthread_rwlock_timedwrlock").return {
    if (pid() != target())
	next;
    result = @RETURN;
    rwlock	= @ENTRY_ARG1;
    tmout	= @ENTRY_ARG2;
    common_wrlock(rwlock, 0, tmout, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_unlock").return !,
process("/lib64/libc.so.6").function("pthread_rwlock_unlock").return {
    if (pid() != target())
	next;
    result = @RETURN;
    rwlock = @ENTRY_ARG1;
    rd = rdlocks[rwlock];
    if (result)
	report_error(ppfunc(), result);
    else {
	if (verbose) {
	    now = gettimeofday_us();
	    if (rd) {
		diff = now - rdlock_entry[tid(), rwlock];
		rdlock_total_time[rwlock] += diff;
		if (!rdlock_min_time[rwlock] ||
		    rdlock_min_time[rwlock] > diff)
		    rdlock_min_time[rwlock] = diff;
		if (rdlock_max_time[rwlock] < diff)
		    rdlock_max_time[rwlock] = diff;
	    }
	    else {
		diff = now - wrlock_entry[tid(), rwlock];
		wrlock_total_time[rwlock] += diff;
		if (!wrlock_min_time[rwlock] ||
		    wrlock_min_time[rwlock] > diff)
		    wrlock_min_time[rwlock] = diff;
		if (wrlock_max_time[rwlock] < diff)
		    wrlock_max_time[rwlock] = diff;
	    }
	}
    }
    if (rd) {
	delete rdlocks[rwlock];
	delete rdlock_entry[tid(), rwlock];
	delete rdlock_entry_timer[tid(), rwlock];
    }
    else {
	delete wrlocks[rwlock];
	delete wrlock_entry[tid(), rwlock];
	delete wrlock_entry_timer[tid(), rwlock];
    }
}

function
forget_rwlock(rwlock)
{
    delete rdlocks[rwlock];
    delete wrlocks[rwlock];
    if (verbose) {
	delete rdlock_count[rwlock];
	delete wrlock_count[rwlock];
	delete rdlock_contention_total_time[rwlock];
	delete wrlock_contention_total_time[rwlock];
	delete rdlock_contention_min_time[rwlock];
	delete wrlock_contention_min_time[rwlock];
	delete rdlock_contention_max_time[rwlock];
	delete wrlock_contention_max_time[rwlock];
	delete wrlock_contention_fail_try[rwlock];
	delete wrlock_contention_fail_timed[rwlock];
	delete rdlock_total_time[rwlock];
	delete wrlock_total_time[rwlock];
	delete rdlock_min_time[rwlock];
	delete wrlock_min_time[rwlock];
	delete rdlock_max_time[rwlock];
	delete wrlock_max_time[rwlock];
	foreach ([tid, key] in rdlock_contention_per_thread) {
	    if (key == rwlock)
		delete rdlock_contention_per_thread[tid, rwlock];
	}
	foreach ([tid, key] in wrlock_contention_per_thread) {
	    if (key == rwlock)
		delete wrlock_contention_per_thread[tid, rwlock];
	}
    }
    /* Should never happen or an error already triggered */
    if (expensive_checks) {
	foreach ([tid, key] in rdlock_entry) {
	    if (key == rwlock)
		delete rdlock_entry[tid, rwlock];
	}
	foreach ([tid, key] in rdlock_entry_timer) {
	    if (key == rwlock)
		delete rdlock_entry_timer[tid, rwlock];
	}
	foreach ([tid, key] in wrlock_entry) {
	    if (key == rwlock)
		delete wrlock_entry[tid, rwlock];
	}
	foreach ([tid, key] in wrlock_entry_timer) {
	    if (key == rwlock)
		delete wrlock_entry_timer[tid, rwlock];
	}
    }
}

probe
process("/lib64/libc.so.6").function("__pthread_rwlock_destroy").return !,
process("/lib64/libc.so.6").function("pthread_rwlock_destroy").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	rwlock	= @ENTRY_ARG1;
	rwlock_init[rwlock] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process("/lib64/libc.so.6").function("__pthread_spin_init").return !,
process("/lib64/libc.so.6").function("pthread_spin_init").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	spin	= @ENTRY_ARG1;
	/*
	shared	= @ENTRY_ARG2;
	 */
	check_memory_reuse(spin);
	spin_init[spin] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

function
common_spin_lock(spin, istry, result) {
    if (result == 0) {
	spinlocks[spin] = tid();
	now = gettimeofday_us();
	if (verbose) {
	    ++spin_count[spin];
	    diff = now - spin_entry[tid(), spin];
	    spin_contention_total_time[spin] += diff;
	    if (!spin_contention_min_time[spin] ||
		spin_contention_min_time[spin] > diff)
		spin_contention_min_time[spin] = diff;
	    if (spin_contention_max_time[spin] < diff)
		spin_contention_max_time[spin] = diff;
	    ++spin_contention_count[spin];
	    ++spin_contention_per_thread[tid(), spin];
	}
	spin_entry[tid(), spin] = now;
    }
    else {
	report = 1;
	if (istry) {
	    report = !trap_on_expected_busy || result != @EBUSY;
	    ++spin_contention_fail_try[spin];
	}
	if (report)
	    report_error(ppfunc(), result);
	delete spin_entry[tid(), spin];
    }
}

probe
process("/lib64/libc.so.6").function("__pthread_spin_lock") !,
process("/lib64/libc.so.6").function("pthread_spin_lock") {
    if (pid() != target())
	next;
    spin	= @ARG1;
    spin_entry[tid(), spin] = gettimeofday_us();
}

probe
process("/lib64/libc.so.6").function("__pthread_spin_lock").return !,
process("/lib64/libc.so.6").function("pthread_spin_lock").return {
    if (pid() != target())
	next;
    result	= @RETURN;
    spin	= @ENTRY_ARG1;
    common_spin_lock(spin, 0, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_spin_trylock") !,
process("/lib64/libc.so.6").function("pthread_spin_trylock") {
    if (pid() != target())
	next;
    spin	= @ARG1;
    spin_entry[tid(), spin] = gettimeofday_us();
}

probe
process("/lib64/libc.so.6").function("__pthread_spin_trylock").return !,
process("/lib64/libc.so.6").function("pthread_spin_trylock").return {
    if (pid() != target())
	next;
    result	= @RETURN;
    spin	= @ENTRY_ARG1;
    common_spin_lock(spin, 1, result);
}

probe
process("/lib64/libc.so.6").function("__pthread_spin_unlock").return !,
process("/lib64/libc.so.6").function("pthread_spin_unlock").return {
    if (pid() != target())
	next;
    result = @RETURN;
    spin = @ENTRY_ARG1;
    if (result)
	report_error(ppfunc(), result);
    else {
	if (verbose) {
	    --spin_count[spin];
	    now = gettimeofday_us();
	    diff = now - spin_entry[tid(), spin];
	    spin_total_time[spin] += diff;
	    if (!spin_min_time[spin] ||	spin_min_time[spin] > diff)
		spin_min_time[spin] = diff;
	    if (spin_max_time[spin] < diff)
		spin_max_time[spin] = diff;
	}
    }
    delete spinlocks[spin];
    delete spin_entry[tid(), spin];
}

function
forget_spinlock(spin) {
    delete spinlocks[spin];
    if (expensive_checks) {
	foreach ([tid, key] in spin_entry) {
	    if (key == spin) {
		delete spin_entry[tid, spin];
		break;
	    }
	}
    }
    delete spin_count[spin];
    if (verbose) {
	delete spin_contention_total_time[spin];
	delete spin_contention_min_time[spin];
	delete spin_contention_max_time[spin];
	delete spin_contention_count[spin];
	delete spin_contention_fail_try[spin];
	foreach ([tid, key] in spin_contention_per_thread) {
	    if (key == spin) {
		delete spin_contention_per_thread[tid, spin];
		break;
	    }
	}
	delete spin_total_time[spin];
	delete spin_min_time[spin];
	delete spin_max_time[spin];
    }
}

function
check_memory_reuse(pointer) {
    if (mutex_init[pointer])
	forget_mutex(pointer);
    else if (cond_init[pointer])
	forget_condition(pointer);
    else if (rwlock_init[pointer])
	forget_rwlock(pointer);
    else if (spin_init[pointer])
	forget_spinlock(pointer);
}

probe
process("/lib64/libc.so.6").function("__pthread_spin_destroy").return !,
process("/lib64/libc.so.6").function("pthread_spin_destroy").return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	spin	= @ENTRY_ARG1;
	spin_init[spin] = -1;
    }
    else
	report_error(ppfunc(), result);
}

function plural(count) {
    return count != 1 ? "s" : "";
}

function comma(count) {
    return count ? ", ": "";
}

function and(count) {
    return count ? " and ": "";
}

function time_string(usec:long) {
    result = "";
    msec = sec = min = hour = day = 0;
    temp = usec % 1000000;
    if (temp != usec) {
	msec = usec / 1000;
	usec = temp;
	if (msec) {
	    sec = msec / 1000;
	    if (sec) {
		msec %= 1000;
		min = sec / 60;
		if (min) {
		    sec %= 60;
		    hour = min / 60;
		    if (hour) {
			min %= 60;
			day = hour / 24;
			if (day)
			    hour %= 24;
		    }
		}
	    }
	}
    }
    if (day)
	result .= sprintf("%ld day%s", day, plural(day));
    if (hour)
	result .= sprintf("%s%ld hour%s",
			  comma(day), hour, plural(hour));
    if (min)
	result .= sprintf("%s%ld min%s",
			  comma(hour || day), min, plural(min));
    if (sec)
	result .= sprintf("%s%ld sec%s",
			  comma(min || hour || day),
			  sec, plural(sec));
    if (msec)
	result .= sprintf("%s%ld msec%s",
			  comma(sec || min || hour || day),
			  msec, plural(msec));
    if (usec)
	result .= sprintf("%s%ld usec%s",
			  and(msec || sec || min || hour || day),
			  usec, plural(usec));
    return result;
}

function report() {
    printf("\nReport for %s (%s)\n", process_name, process_arguments);
    if (verbose) {
	printf("tid to pthread\n");
	foreach (tid in tid_to_thread) {
	    thread = tid_to_thread[tid];
	    printf("    %ld %p %s\n", tid, thread, thread_name[thread]);
	}
    }
    if (verbose) {
	count = 0;
	foreach ([tid, mutex] in mutex_contention_per_thread) {
	    ++details_thread_count[mutex];
	}
	foreach (mutex in mutex_contention_total_time) {
	    details[mutex, mutex_contention_total_time[mutex]] =
		details_thread_count[mutex];
	}
	delete details_thread_count;
	foreach ([mutex, time-] in details) {
	    if (mutex_contention_count[mutex]) {
		if (count++ >= report_mutex_count)
		    break;
		if (mutex_init[mutex])
		    printf("%s ",
			   mutex_init[mutex] > 0 ?
			   "initialized" : "*destroyed");
		if (mutex_consistent[mutex])
		    printf("%sconsistent ",
			   mutex_consistent[mutex] < 0 ? "*in" : "");
		if (mutex_prioceiling[mutex])
		    printf("%ld prioceiling ", mutex_prioceiling[mutex]);
		printf("mutex %p locked %ld time%s by %ld thread%s",
		       mutex,
		       mutex_contention_count[mutex],
		       plural(mutex_contention_count[mutex]),
		       details[mutex, time],
		       plural(details[mutex, time]));
		if (mutex_contention_fail_try[mutex])
		    printf(", %ld failed lock%s",
			   mutex_contention_fail_try[mutex],
			   plural(mutex_contention_fail_try[mutex]));
		if (mutex_contention_fail_timed[mutex])
		    printf(", %ld timedout lock%s",
			   mutex_contention_fail_timed[mutex],
			   plural(mutex_contention_fail_timed[mutex]));
		printf("\n");
		printf("    total contention	: %s\n", time_string(time));
		printf("    min contention	: %s\n",
		       time_string(mutex_contention_min_time[mutex]));
		printf("    max contention	: %s\n",
		       time_string(mutex_contention_max_time[mutex]));
		printf("    average contention	: %s\n",
		       time_string(mutex_contention_total_time[mutex] /
				   mutex_contention_count[mutex]));
		printf("    total lock		: %s\n",
		       time_string(mutex_lock_total_time[mutex]));
		printf("    min lock		: %s\n",
		       time_string(mutex_lock_min_time[mutex]));
		printf("    max lock		: %s\n",
		       time_string(mutex_lock_max_time[mutex]));
		printf("    average lock	: %s\n",
		       time_string(mutex_lock_total_time[mutex] /
				   mutex_contention_count[mutex]));
	    }
	}
	delete details;
    }

    now = gettimeofday_us();
    foreach (mutex in mutex_lock) {
	tid = mutex_lock[mutex];
	if (tid)
	    details[mutex, now - mutex_lock_entry[tid, mutex]] = tid;
    }
    /* Order by time locked */
    foreach ([mutex, time-] in details) {
	if (mutex_init[mutex])
	    printf("%s ",
		   mutex_init[mutex] > 0 ? "initialized" : "*destroyed");
	if (mutex_consistent[mutex])
	    printf("%sconsistent ", mutex_consistent[mutex] < 0 ? "*in" : "");
	if (mutex_prioceiling[mutex])
	    printf("%ld prioceiling ", mutex_prioceiling[mutex]);
	locker = mutex_lock[mutex];
	printf("mutex %p locked for %s by tid %ld\n",
	       mutex, time_string(time), locker);
	foreach ([tid, key] in mutex_lock_entry) {
	    if (key == mutex && tid != locker && mutex_lock_entry[tid, key])
		printf("    tid %ld waiting for %s\n", tid,
		       time_string(now - mutex_lock_entry[tid, key]));
	}
    }
    delete details;

    if (verbose) {
	count = 0;
	foreach ([tid, cond] in cond_wait_per_thread) {
	    ++details_thread_count[cond];
	}
	foreach ([tid, cond] in cond_signal_per_thread) {
	    ++details_signal_count[cond];
	}
	foreach ([tid, cond] in cond_broadcast_per_thread) {
	    ++details_broadcast_count[cond];
	}
	foreach (cond in cond_wait_total_time) {
	    details[cond, cond_wait_total_time[cond]] =
		details_thread_count[cond];
	}
	delete details_thread_count;
	foreach ([cond, time-] in details) {
	    if (count++ >= report_cond_count)
		break;
	    printf("%s ",
		   cond_init[cond] > 0 ? "initialized" : "*destroyed");
	    printf("condition %p waited %ld time%s by %ld thread%s",
		   cond,
		   cond_wait_count[cond],
		   plural(cond_wait_count[cond]),
		   details[cond, time],
		   plural(details[cond, time]));
		if (cond_wait_timedout[cond])
		    printf(", %ld timedout waits",
			   cond_wait_timedout[cond]);
	    if (cond_signal_count[cond])
		printf(", signaled %ld time%s by %ld thread%s",
		       cond_signal_count[cond],
		       plural(cond_signal_count[cond]),
		       details_signal_count[cond],
		       plural(details_signal_count[cond]));
	    if (cond_broadcast_count[cond])
		printf(", broadcast %ld time%s by %ld thread%s",
		       cond_broadcast_count[cond],
		       plural(cond_broadcast_count[cond]),
		       details_broadcast_count[cond],
		       plural(details_broadcast_count[cond]));
		printf("\n");
		printf("    total wait	: %s\n", time_string(time));
		printf("    min wait	: %s\n",
		       time_string(cond_wait_min_time[cond]));
		printf("    max wait	: %s\n",
		       time_string(cond_wait_max_time[cond]));
		printf("    average wait: %s\n",
		       time_string(cond_wait_total_time[cond] /
				   cond_wait_count[cond]));
	}
	delete details_broadcast_count;
	delete details_signal_count;
	delete details;
    }

    foreach ([tid, cond] in cond_wait) {
	if (cond_wait[tid, cond]) {
	    conditions[cond] = 1;
	    details[cond, now - cond_wait[tid, cond]] = tid;
	}
    }
    foreach (condition in conditions) {
	printf("%s ",
	       cond_init[condition] > 0 ? "initialized" : "*destroyed");
	printf("condition %p\n", condition);
	foreach ([cond, time-] in details) {
	    if (cond == condition) {
		tid = details[cond, time];
		mutex = mutex_wait[tid, cond];
		printf("    mutex %p waiting for %s by tid %ld\n",
		       mutex, time_string(time), tid);
	    }
	}
    }
    delete details;
    delete conditions;

    if (verbose) {
	count = 0;
	foreach ([tid, rdlock] in rdlock_contention_per_thread) {
	    ++details_thread_count[rdlock];
	}
	foreach (rdlock in rdlock_contention_total_time) {
	    details[rdlock, rdlock_contention_total_time[rdlock]] =
		details_thread_count[rdlock];
	}
	delete details_thread_count;
	foreach ([rdlock, time-] in details) {
	    if (rdlock_contention_count[rdlock]) {
		if (count++ >= report_rdlock_count)
		    break;
		if (rwlock_init[rdlock])
		    printf("%s ",
			   rwlock_init[rdlock] > 0 ?
			   "initialized" : "*destroyed");
		printf("rdlock %p locked %ld time%s by %ld thread%s",
		       rdlock,
		       rdlock_contention_count[rdlock],
		       plural(rdlock_contention_count[rdlock]),
		       details[rdlock, time],
		       plural(details[rdlock, time]));
		if (rdlock_contention_fail_try[rdlock])
		    printf(", %ld failed lock%s",
			   rdlock_contention_fail_try[rdlock],
			   plural(rdlock_contention_fail_try[rdlock]));
		if (rdlock_contention_fail_timed[rdlock])
		    printf(", %ld timedout lock%s",
			   rdlock_contention_fail_timed[rdlock],
			   plural(rdlock_contention_fail_timed[rdlock]));
		printf("\n");
		printf("    total contention	: %s\n", time_string(time));
		printf("    min contention	: %s\n",
		       time_string(rdlock_contention_min_time[rdlock]));
		printf("    max contention	: %s\n",
		       time_string(rdlock_contention_max_time[rdlock]));
		printf("    average contention	: %s\n",
		       time_string(rdlock_contention_total_time[rdlock] /
				   rdlock_contention_count[rdlock]));
		printf("    total lock		: %s\n",
		       time_string(rdlock_total_time[rdlock]));
		printf("    min lock		: %s\n",
		       time_string(rdlock_min_time[rdlock]));
		printf("    max lock		: %s\n",
		       time_string(rdlock_max_time[rdlock]));
		printf("    average lock	: %s\n",
		       time_string(rdlock_total_time[rdlock] /
				   rdlock_contention_count[rdlock]));
	    }
	}
	delete details;
    }
    foreach (rdlock in rdlocks) {
	tid = rdlocks[rdlock];
	if (tid)
	    details[rdlock, now - rdlock_entry[tid, rdlock]] = tid;
    }
    foreach ([rdlock, time-] in details) {
	if (rwlock_init[rdlock])
	    printf("%s ",
		   rwlock_init[rdlock] > 0 ? "initialized" : "*destroyed");
	locker = rdlocks[rdlock];
	printf("rwlock read lock %p by %ld\n", rdlock, locker);
	foreach ([tid, key] in rdlock_entry) {
	    if (key == rdlock && tid != locker && rdlock_entry[tid, key])
		printf("    tid %ld waiting for %s\n", tid,
		       time_string(now - rdlock_entry[tid, key]));
	}
    }
    delete details;

    if (verbose) {
	count = 0;
	foreach ([tid, wrlock] in wrlock_contention_per_thread) {
	    ++details_thread_count[wrlock];
	}
	foreach (wrlock in wrlock_contention_total_time) {
	    details[wrlock, wrlock_contention_total_time[wrlock]] =
		details_thread_count[wrlock];
	}
	delete details_thread_count;
	foreach ([wrlock, time-] in details) {
	    if (wrlock_contention_count[wrlock]) {
		if (count++ >= report_wrlock_count)
		    break;
		if (rwlock_init[wrlock])
		    printf("%s ",
			   rwlock_init[wrlock] > 0 ?
			   "initialized" : "*destroyed");
		printf("wrlock %p locked %ld time%s by %ld thread%s",
		       wrlock,
		       wrlock_contention_count[wrlock],
		       plural(wrlock_contention_count[wrlock]),
		       details[wrlock, time],
		       plural(details[wrlock, time]));
		if (wrlock_contention_fail_try[wrlock])
		    printf(", %ld failed lock%s",
			   wrlock_contention_fail_try[wrlock],
			   plural(wrlock_contention_fail_try[wrlock]));
		if (wrlock_contention_fail_timed[wrlock])
		    printf(", %ld timedout lock%s",
			   wrlock_contention_fail_timed[wrlock],
			   plural(wrlock_contention_fail_timed[wrlock]));
		printf("\n");
		printf("    total contention	: %s\n", time_string(time));
		printf("    min contention	: %s\n",
		       time_string(wrlock_contention_min_time[wrlock]));
		printf("    max contention	: %s\n",
		       time_string(wrlock_contention_max_time[wrlock]));
		printf("    average contention	: %s\n",
		       time_string(wrlock_contention_total_time[wrlock] /
				   wrlock_contention_count[wrlock]));
		printf("    total lock		: %s\n",
		       time_string(wrlock_total_time[wrlock]));
		printf("    min lock		: %s\n",
		       time_string(wrlock_min_time[wrlock]));
		printf("    max lock		: %s\n",
		       time_string(wrlock_max_time[wrlock]));
		printf("    average lock	: %s\n",
		       time_string(wrlock_total_time[wrlock] /
				   wrlock_contention_count[wrlock]));
	    }
	}
	delete details;
    }
    foreach (wrlock in wrlocks) {
	tid = wrlocks[wrlock];
	if (tid)
	    details[wrlock, now - wrlock_entry[tid, wrlock]] = tid;
    }
    foreach ([wrlock, time-] in details) {
	if (rwlock_init[wrlock])
	    printf("%s ",
		   rwlock_init[wrlock] > 0 ? "initialized" : "*destroyed");
	locker = wrlocks[wrlock];
	printf("rwlock write lock %p by %ld\n", wrlock, locker);
	foreach ([tid, key] in wrlock_entry) {
	    if (key == wrlock && tid != locker && wrlock_entry[tid, key])
		printf("    tid %ld waiting for %s\n", tid,
		       time_string(now - wrlock_entry[tid, key]));
	}
    }
    delete details;

    if (verbose) {
	count = 0;
	foreach ([tid, spin] in spin_contention_per_thread) {
	    ++details_thread_count[spin];
	}
	foreach (spin in spin_contention_total_time) {
	    details[spin, spin_contention_total_time[spin]] =
		details_thread_count[spin];
	}
	delete details_thread_count;
	foreach ([spin, time-] in details) {
	    if (spin_contention_count[spin]) {
		if (count++ >= report_spin_count)
		    break;
		if (rwlock_init[spin])
		    printf("%s ",
			   spin_init[spin] > 0 ?
			   "initialized" : "*destroyed");
		printf("spin %p locked %ld time%s by %ld thread%s",
		       spin,
		       spin_contention_count[spin],
		       plural(spin_contention_count[spin]),
		       details[spin, time],
		       plural(details[spin, time]));
		if (spin_contention_fail_try[spin])
		    printf(", %ld failed lock%s",
			   spin_contention_fail_try[spin],
			   plural(spin_contention_fail_try[spin]));
		printf("\n");
		printf("    total contention	: %s\n", time_string(time));
		printf("    min contention	: %s\n",
		       time_string(spin_contention_min_time[spin]));
		printf("    max contention	: %s\n",
		       time_string(spin_contention_max_time[spin]));
		printf("    average contention	: %s\n",
		       time_string(spin_contention_total_time[spin] /
				   spin_contention_count[spin]));
		printf("    total lock		: %s\n",
		       time_string(spin_total_time[spin]));
		printf("    min lock		: %s\n",
		       time_string(spin_min_time[spin]));
		printf("    max lock		: %s\n",
		       time_string(spin_max_time[spin]));
		printf("    average lock	: %s\n",
		       time_string(spin_total_time[spin] /
				   spin_contention_count[spin]));
	    }
	}
	delete details;
    }
    foreach (spin in spinlocks) {
	tid = spinlocks[spin];
	if (tid)
	    details[spin, now - spin_entry[tid, spin]] = tid;
    }
    foreach ([spin, time-] in details) {
	if (spin_init[spin])
	    printf("%s ",
		   spin_init[spin] > 0 ? "initialized" : "*destroyed");
	locker = spinlocks[spin];
	printf("spinlock %p by %ld\n", spin, locker);
	foreach ([tid, key] in spin_entry) {
	    if (key == spin && tid != locker && spin_entry[tid, key])
		printf("    tid %ld waiting for %s\n", tid,
		       time_string(now - spin_entry[tid, key]));
	}
    }
    delete details;
}

probe signal.send {
    if (sig_name == "SIGURG" && sig_pid == target())
	report();
}

probe kprocess.exec {
    if (pid() != target())
	next;
    exec_process_arguments = argstr;
}

probe kprocess.exec_complete {
    if (pid() != target())
	next;
    if (success) {
	if (process_name != "") {
	    report();
	    reset();
	}
	process_name = execname();
	process_arguments = exec_process_arguments;
    }
}

function reset() {
    delete tid_to_thread;
    delete thread_to_tid;
    if (verbose) {
	delete thread_name;
	delete mutex_contention_total_time;
	delete mutex_contention_min_time;
	delete mutex_contention_max_time;
	delete mutex_contention_count;
	delete mutex_contention_per_thread;
	delete mutex_contention_fail_try;
	delete mutex_contention_fail_timed;
	delete mutex_lock_total_time;
	delete mutex_lock_min_time;
	delete mutex_lock_max_time;
	delete cond_wait_count;
	delete cond_wait_per_thread;
	delete cond_wait_total_time;
	delete cond_wait_min_time;
	delete cond_wait_max_time;
	delete cond_wait_timedout;
	delete cond_signal_count;
	delete cond_signal_per_thread;
	delete cond_broadcast_count;
	delete cond_broadcast_per_thread;
	delete rdlock_count;
	delete rdlock_contention_total_time;
	delete rdlock_contention_min_time;
	delete rdlock_contention_max_time;
	delete rdlock_contention_count;
	delete rdlock_contention_per_thread;
	delete rdlock_contention_fail_try;
	delete rdlock_contention_fail_timed;
	delete rdlock_total_time;
	delete rdlock_min_time;
	delete rdlock_max_time;
	delete wrlock_count;
	delete wrlock_contention_total_time;
	delete wrlock_contention_min_time;
	delete wrlock_contention_max_time;
	delete wrlock_contention_count;
	delete wrlock_contention_per_thread;
	delete wrlock_contention_fail_try;
	delete wrlock_contention_fail_timed;
	delete wrlock_total_time;
	delete wrlock_min_time;
	delete wrlock_max_time;
	delete spin_count;
	delete spin_contention_total_time;
	delete spin_contention_min_time;
	delete spin_contention_max_time;
	delete spin_contention_count;
	delete spin_contention_per_thread;
	delete spin_contention_fail_try;
	delete spin_total_time;
	delete spin_min_time;
	delete spin_max_time;
    }
    delete mutex_lock;
    delete mutex_lock_entry;
    delete mutex_lock_entry_timer;
    delete mutex_consistent;
    delete mutex_prioceiling;
    delete mutex_init;
    delete mutex_wait;
    delete cond_wait;
    delete cond_wait_timer;
    delete cond_init;
    delete rwlock_init;
    delete rdlocks;
    delete rdlock_entry;
    delete rdlock_entry_timer;
    delete wrlocks;
    delete wrlock_entry;
    delete wrlock_entry_timer;
    delete spin_init;
    delete spin_entry;
    delete spinlocks;
}

probe end {
    report();
    reset();
    printf("Stap done.\n");
}
