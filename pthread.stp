#!/usr/bin/stap

/* Sample usage:

$ stap pthread.stp -DDMAXMAPENTRIES=65536 -DMAXACTION=65536 -DSTP_OVERLOAD_THRESHOLD=1073741824LL -Gverbose=1 -c 'java -jar /path/to/sample.jar'
Stap ready.
...
Report for java ("/usr/bin/java", ["java", "-jar", ...]
tid to pthread
    782045 0x7f97e64006c0 
    782046 0x7f97cffff6c0 
    782047 0x7f97d47ff6c0 GC Thread#0
    782048 0x7f97d46fe6c0 G1 Main Marker
    782049 0x7f97d45fd6c0 G1 Conc#0
    782050 0x7f97cd6f66c0 G1 Refine#0
    782051 0x7f97cd5f56c0 G1 Service
    782052 0x7f97cd4f46c0 VM Periodic Tas
    782053 0x7f97cd32d6c0 VM Thread
    782054 0x7f97cd22c6c0 Reference Handl
    782055 0x7f97cd12c6c0 Finalizer
    782056 0x7f97cd02c6c0 Signal Dispatch
    782057 0x7f97ccf2c6c0 Service Thread
    782058 0x7f97cce2c6c0 Monitor Deflati
    782059 0x7f97ccd2c6c0 C2 CompilerThre
    782060 0x7f97ccc2c6c0 C1 CompilerThre
    782061 0x7f97cca5b6c0 Notification Th
    782062 0x7f97cc95b6c0 Common-Cleaner
    782063 0x7f97cc85b6c0 C1 CompilerThre
    782064 0x7f97cc75b6c0 Java2D Disposer
    782065 0x7f97cc65b6c0 AWT-XAWT
    782069 0x7f97cc75b6c0 Java2D Disposer
    782070 0x7f97cc65b6c0 AWT-XAWT
    782071 0x7f97cc41d6c0 Timer-0
    782072 0x7f97cc41d6c0 Timer-0
    782073 0x7f97cc2ef6c0 TimerQueue
    782074 0x7f97cc1ef6c0 Sync Timer Thre
    782075 0x7f97c7fff6c0 AWT-Shutdown
    782076 0x7f97cc41d6c0 Timer-0
    782077 0x7f97cc75b6c0 Java2D Disposer
    782078 0x7f97cc65b6c0 AWT-XAWT
    782079 0x7f97cc2ef6c0 TimerQueue
    782080 0x7f97cc1ef6c0 Sync Timer Thre
    782081 0x7f97c7fff6c0 AWT-Shutdown
    782082 0x7f97a07ff6c0 AWT-EventQueue-
    782083 0x7f97a06ff6c0 Image Fetcher 3
    782084 0x7f97a05ff6c0 XToolkt-Shutdow
    782085 0x7f97a06ff6c0 Image Fetcher 3
    782088 0x7f97cc2ef6c0 TimerQueue
    782090 0x7f97cc1ef6c0 Sync Timer Thre
    782091 0x7f97a05ff6c0 XToolkt-Shutdow
    782092 0x7f97e65246c0 Logging-Cleaner
    782093 0x7f97a04ff6c0 pool-1-thread-1
mutex 0x7f97e7d95c60 locked 65583 times by 18 threads
    total contention	: 2 secs, 523 msecs and 523358 usecs
    min contention	: 10 usecs
    max contention	: 2698 usecs
    average contention	: 38 usecs
    total lock		: 2 secs, 93 msecs and 93838 usecs
    min lock		: 17 usecs
    max lock		: 2647 usecs
    average lock	: 31 usecs
initialized mutex 0x7f97c811de58 locked 74595 times by 19 threads
    total contention	: 1 sec, 19 msecs and 19678 usecs
    min contention	: 11 usecs
    max contention	: 442 usecs
    average contention	: 13 usecs
    total lock		: 1 sec, 600 msecs and 600888 usecs
    min lock		: 17 usecs
    max lock		: 1054 usecs
    average lock	: 21 usecs
initialized mutex 0x7f97e7d71828 locked 45728 times by 8 threads
    total contention	: 590573 usecs
    min contention	: 11 usecs
    max contention	: 450 usecs
    average contention	: 12 usecs
    total lock		: 933318 usecs
    min lock		: 17 usecs
    max lock		: 2099 usecs
    average lock	: 20 usecs
initialized mutex 0x7f97e7d6f728 locked 37638 times by 25 threads, 65 failed locks
    total contention	: 509487 usecs
    min contention	: 11 usecs
    max contention	: 420 usecs
    average contention	: 13 usecs
    total lock		: 1 sec, 120 msecs and 120278 usecs
    min lock		: 18 usecs
    max lock		: 1002 usecs
    average lock	: 29 usecs
initialized mutex 0x7f97e7d6ff28 locked 30450 times by 26 threads
    total contention	: 430220 usecs
    min contention	: 10 usecs
    max contention	: 629 usecs
    average contention	: 14 usecs
    total lock		: 1 sec, 187 msecs and 187065 usecs
    min lock		: 17 usecs
    max lock		: 1394 usecs
    average lock	: 38 usecs
initialized mutex 0x7f97e7d6fea8 locked 25084 times by 28 threads
    total contention	: 353657 usecs
    min contention	: 11 usecs
    max contention	: 361 usecs
    average contention	: 14 usecs
    total lock		: 557623 usecs
    min lock		: 17 usecs
    max lock		: 527 usecs
    average lock	: 22 usecs
initialized mutex 0x7f97c81659e8 locked 23887 times by 8 threads
    total contention	: 332191 usecs
    min contention	: 11 usecs
    max contention	: 443 usecs
    average contention	: 13 usecs
    total lock		: 539914 usecs
    min lock		: 17 usecs
    max lock		: 468 usecs
    average lock	: 22 usecs
initialized mutex 0x7f97e7d6fda8 locked 12386 times by 28 threads, 335 failed locks
    total contention	: 256285 usecs
    min contention	: 11 usecs
    max contention	: 3458 usecs
    average contention	: 20 usecs
    total lock		: 1 sec, 696 msecs and 696440 usecs
    min lock		: 17 usecs
    max lock		: 1734 usecs
    average lock	: 136 usecs
initialized mutex 0x7f97e7d711a8 locked 11574 times by 22 threads
    total contention	: 253931 usecs
    min contention	: 11 usecs
    max contention	: 706 usecs
    average contention	: 21 usecs
    total lock		: 370680 usecs
    min lock		: 17 usecs
    max lock		: 536 usecs
    average lock	: 32 usecs
initialized mutex 0x7f97e7d6f7a8 locked 17034 times by 21 threads, 40 failed locks
    total contention	: 248020 usecs
    min contention	: 11 usecs
    max contention	: 496 usecs
    average contention	: 14 usecs
    total lock		: 388537 usecs
    min lock		: 17 usecs
    max lock		: 1248 usecs
    average lock	: 22 usecs
initialized mutex 0x7f97e7d6fd28 locked for 28 secs, 551 msecs and 551464 usecs by tid 782054
    tid 782046 waiting for 11 secs, 440 msecs and 440502 usecs
    tid 782082 waiting for 456680 usecs
initialized mutex 0x7f97c8156328 locked for 28 secs, 550 msecs and 550984 usecs by tid 782055
initialized mutex 0x7f97e7d71d28 locked for 28 secs, 534 msecs and 534844 usecs by tid 782058
initialized mutex 0x7f97e7d71c28 locked for 28 secs, 347 msecs and 347845 usecs by tid 782061
initialized mutex 0x7f97c816ed50 locked for 28 secs, 282 msecs and 282980 usecs by tid 782062
initialized mutex 0x7f97c83d7500 locked for 12 secs, 921 msecs and 921303 usecs by tid 782077
initialized mutex 0x7f97380f7eb8 locked for 11 secs, 448 msecs and 448876 usecs by tid 782079
    tid 782063 waiting for 8 secs, 255 msecs and 255855 usecs
initialized mutex 0x7f97e7d6fe28 locked for 11 secs, 286 msecs and 286645 usecs by tid 782046
    tid 782053 waiting for 456308 usecs
    tid 782079 waiting for 3 secs, 995 msecs and 995693 usecs
    tid 782063 waiting for 8 secs, 391 msecs and 391961 usecs
    tid 782084 waiting for 7 secs, 954 msecs and 954631 usecs
    tid 782083 waiting for 7 secs, 754 msecs and 754017 usecs
    tid 782080 waiting for 3 secs, 995 msecs and 995995 usecs
    tid 782082 waiting for 505587 usecs
    tid 782076 waiting for 508828 usecs
    tid 782092 waiting for 498755 usecs
    tid 782091 waiting for 472743 usecs
    tid 782090 waiting for 471481 usecs
    tid 782093 waiting for 458968 usecs
    tid 782056 waiting for 456190 usecs
initialized mutex 0x7f96cc12f050 locked for 3 secs, 162 msecs and 162647 usecs by tid 782088
    tid 782082 waiting for 3 secs, 667 msecs and 667355 usecs
initialized mutex 0x7f96dc038128 locked for 2 secs, 453 msecs and 453229 usecs by tid 782085
    tid 782082 waiting for 2 secs, 494 msecs and 494440 usecs
initialized mutex 0x7f97e7d6fb28 locked for 1 sec, 182 msecs and 182956 usecs by tid 782053
    tid 782046 waiting for 13 secs, 302 msecs and 302486 usecs
    tid 782082 waiting for 456655 usecs
initialized mutex 0x7f96f4020728 locked for 515292 usecs by tid 782081
    tid 782082 waiting for 516074 usecs
mutex 0x7f97e7d95c60 locked for 458594 usecs by tid 782063
    tid 782059 waiting for 488653 usecs
    tid 782079 waiting for 3 secs, 995 msecs and 995260 usecs
    tid 782080 waiting for 3 secs, 995 msecs and 995454 usecs
    tid 782060 waiting for 458157 usecs
    tid 782046 waiting for 11 secs, 288 msecs and 288229 usecs
    tid 782082 waiting for 504713 usecs
    tid 782078 waiting for 699492 usecs
    tid 782083 waiting for 7 secs, 753 msecs and 753587 usecs
    tid 782084 waiting for 7 secs, 954 msecs and 954195 usecs
    tid 782052 waiting for 3 secs, 175 msecs and 175090 usecs
    tid 782085 waiting for 2 secs, 459 msecs and 459347 usecs
    tid 782088 waiting for 3 secs, 163 msecs and 163658 usecs
    tid 782091 waiting for 472013 usecs
    tid 782090 waiting for 470918 usecs
    tid 782076 waiting for 499696 usecs
    tid 782092 waiting for 498057 usecs
    tid 782093 waiting for 458290 usecs
initialized mutex 0x7f97e7d71ca8 locked for 458224 usecs by tid 782057
    tid 782065 waiting for 27 secs, 796 msecs and 796812 usecs
    tid 782064 waiting for 27 secs, 744 msecs and 744930 usecs
    tid 782053 waiting for 456074 usecs
    tid 782071 waiting for 22 secs, 283 msecs and 283155 usecs
    tid 782075 waiting for 16 secs, 35 msecs and 35103 usecs
    tid 782074 waiting for 15 secs, 826 msecs and 826578 usecs
    tid 782073 waiting for 15 secs, 714 msecs and 714095 usecs
    tid 782070 waiting for 13 secs, 798 msecs and 798300 usecs
    tid 782069 waiting for 13 secs, 434 msecs and 434252 usecs
    tid 782046 waiting for 11 secs, 288 msecs and 288825 usecs
    tid 782084 waiting for 7 secs, 954 msecs and 954489 usecs
    tid 782083 waiting for 7 secs, 753 msecs and 753841 usecs
    tid 782080 waiting for 3 secs, 995 msecs and 995699 usecs
    tid 782079 waiting for 3 secs, 995 msecs and 995562 usecs
    tid 782076 waiting for 500910 usecs
    tid 782092 waiting for 498434 usecs
    tid 782091 waiting for 472428 usecs
    tid 782090 waiting for 471306 usecs
    tid 782093 waiting for 458686 usecs
initialized mutex 0x7f97e7d712a8 locked for 458120 usecs by tid 782063
    tid 782064 waiting for 27 secs, 887 msecs and 887202 usecs
    tid 782065 waiting for 27 secs, 901 msecs and 901078 usecs
    tid 782071 waiting for 22 secs, 475 msecs and 475611 usecs
    tid 782072 waiting for 15 secs, 948 msecs and 948902 usecs
    tid 782075 waiting for 16 secs, 141 msecs and 141464 usecs
    tid 782073 waiting for 16 secs, 138 msecs and 138996 usecs
    tid 782074 waiting for 15 secs, 942 msecs and 942794 usecs
    tid 782070 waiting for 14 secs, 620 msecs and 620340 usecs
    tid 782069 waiting for 14 secs, 618 msecs and 618042 usecs
    tid 782046 waiting for 11 secs, 295 msecs and 295009 usecs
    tid 782084 waiting for 8 secs, 67 msecs and 67644 usecs
    tid 782083 waiting for 7 secs, 918 msecs and 918002 usecs
    tid 782079 waiting for 4 secs, 683 msecs and 683574 usecs
    tid 782080 waiting for 4 secs, 653 msecs and 653140 usecs
    tid 782078 waiting for 614461 usecs
    tid 782082 waiting for 525341 usecs
    tid 782092 waiting for 500526 usecs
    tid 782059 waiting for 488272 usecs
    tid 782093 waiting for 460826 usecs
    tid 782060 waiting for 457837 usecs
initialized condition 0x7f97e7d724d0 waited 1 time by 1 thread, broadcast 1 time by 1 thread
    total wait	: 28 secs, 83 msecs and 83190 usecs
    min wait	: 28 secs, 83 msecs and 83190 usecs
    max wait	: 28 secs, 83 msecs and 83190 usecs
    average wait: 28 secs, 83 msecs and 83190 usecs
initialized condition 0x7f97c8111e30 waited 1 time by 1 thread, signaled 1 time by 1 thread
    total wait	: 28 secs, 82 msecs and 82422 usecs
    min wait	: 28 secs, 82 msecs and 82422 usecs
    max wait	: 28 secs, 82 msecs and 82422 usecs
    average wait: 28 secs, 82 msecs and 82422 usecs
initialized condition 0x7f97e7d71cd0 waited 24 times by 1 thread, broadcast 26 times by 20 threads
    total wait	: 28 secs, 67 msecs and 67529 usecs
    min wait	: 805 usecs
    max wait	: 3 secs, 757 msecs and 757702 usecs
    average wait: 1 sec, 169 msecs and 169480 usecs
initialized condition 0x7f96f4020750 waited 3 times by 1 thread, signaled 3 times by 1 thread
    total wait	: 10 secs, 792 msecs and 792290 usecs
    min wait	: 1 sec, 825 msecs and 825030 usecs
    max wait	: 7 secs, 129 msecs and 129477 usecs
    average wait: 3 secs, 597 msecs and 597430 usecs
initialized condition 0x7f97c8505208 waited 205 times by 1 thread, signaled 205 times by 2 threads
    total wait	: 3 secs, 120 msecs and 120726 usecs
    min wait	: 103 usecs
    max wait	: 643940 usecs
    average wait: 15223 usecs
initialized condition 0x7f97e7d714d0 waited 3 times by 3 threads, broadcast 1 time by 1 thread
    total wait	: 1 sec, 571 msecs and 571203 usecs
    min wait	: 513766 usecs
    max wait	: 542418 usecs
    average wait: 523734 usecs
initialized condition 0x7f97c8439d48 waited 83 times by 1 thread, signaled 83 times by 3 threads
    total wait	: 925113 usecs
    min wait	: 117 usecs
    max wait	: 254135 usecs
    average wait: 11145 usecs
initialized condition 0x7f97c835d050 waited 20 times by 1 thread, signaled 20 times by 3 threads
    total wait	: 265476 usecs
    min wait	: 460 usecs
    max wait	: 149032 usecs
    average wait: 13273 usecs
initialized condition 0x7f97e7d6fb50 waited 11 times by 2 threads, broadcast 82 times by 3 threads
    total wait	: 17324 usecs
    min wait	: 1294 usecs
    max wait	: 2588 usecs
    average wait: 1574 usecs
initialized condition 0x7f97c83d6b50 waited 1 time by 1 thread, broadcast 2 times by 1 thread
    total wait	: 16782 usecs
    min wait	: 16782 usecs
    max wait	: 16782 usecs
    average wait: 16782 usecs
initialized condition 0x7f97e7d6fd50
    mutex 0x7f97e7d6fd28 waiting for 28 secs, 551 msecs and 551444 usecs by tid 782054
initialized condition 0x7f97c8156350
    mutex 0x7f97c8156328 waiting for 28 secs, 550 msecs and 550961 usecs by tid 782055
initialized condition 0x7f97e7d71c50
    mutex 0x7f97e7d71c28 waiting for 28 secs, 347 msecs and 347824 usecs by tid 782061
initialized condition 0x7f97c83d7528
    mutex 0x7f97c83d7500 waiting for 12 secs, 921 msecs and 921283 usecs by tid 782077
initialized condition 0x7f97e7d6fe50
    mutex 0x7f97e7d6fe28 waiting for 11 secs, 286 msecs and 286628 usecs by tid 782046
initialized condition 0x7f96cc12f078
    mutex 0x7f96cc12f050 waiting for 3 secs, 162 msecs and 162627 usecs by tid 782088
initialized condition 0x7f96f4020750
    mutex 0x7f96f4020728 waiting for 515268 usecs by tid 782081
initialized condition 0x7f97e7d71cd0
    mutex 0x7f97e7d71ca8 waiting for 458202 usecs by tid 782057
initialized condition 0x7f97e7d6fb50
    mutex 0x7f97e7d6fb28 waiting for 456605 usecs by tid 782082
rdlock 0x7f97e7f989e0 locked 2 times by 1 thread
    total contention	: 36 usecs
    min contention	: 12 usecs
    max contention	: 24 usecs
    average contention	: 18 usecs
    total lock		: 71 usecs
    min lock		: 24 usecs
    max lock		: 47 usecs
    average lock	: 35 usecs
rdlock 0x7f97e7f98920 locked 2 times by 1 thread
    total contention	: 30 usecs
    min contention	: 14 usecs
    max contention	: 16 usecs
    average contention	: 15 usecs
    total lock		: 736 usecs
    min lock		: 202 usecs
    max lock		: 534 usecs
    average lock	: 368 usecs
rdlock 0x7f97e7f98a20 locked 2 times by 1 thread
    total contention	: 25 usecs
    min contention	: 12 usecs
    max contention	: 13 usecs
    average contention	: 12 usecs
    total lock		: 48 usecs
    min lock		: 24 usecs
    max lock		: 24 usecs
    average lock	: 24 usecs
rdlock 0x7f97e7f98960 locked 2 times by 1 thread
    total contention	: 24 usecs
    min contention	: 12 usecs
    max contention	: 12 usecs
    average contention	: 12 usecs
    total lock		: 642 usecs
    min lock		: 156 usecs
    max lock		: 486 usecs
    average lock	: 321 usecs
wrlock 0x7f97e7f98920 locked 5 times by 2 threads
    total contention	: 71 usecs
    min contention	: 11 usecs
    max contention	: 20 usecs
    average contention	: 14 usecs
    total lock		: 510 usecs
    min lock		: 21 usecs
    max lock		: 317 usecs
    average lock	: 102 usecs
wrlock 0x7f97e7f98a20 locked 1 time by 1 thread
    total contention	: 16 usecs
    min contention	: 16 usecs
    max contention	: 16 usecs
    average contention	: 16 usecs
    total lock		: 40 usecs
    min lock		: 40 usecs
    max lock		: 40 usecs
    average lock	: 40 usecs
Stap done.
 */

/* -Gtrap_on_all_errors=1 to raise SIGTRAP if any non zero state is returned */
global trap_on_all_errors = 0;
/* -Gtrap_on_XYZ=1 to raise SIGTRAP if related errno is returned; this is a
 * way to globally ignore some errors */
global trap_on_ownerdead = -1;
global trap_on_timedout = -1;
global trap_on_busy = -1;
global trap_on_again = -1;
/* These are for the common/expected cases, of pthread_*_trylock instantly
 * returning when some other thread has the lock, or a lock attempt with
 * a timer that times out. */
global trap_on_expected_busy = 0;
global trap_on_expected_timedout = 0;

/* -Gtrap_on_unexpected=1 to debug either bugs in the script, expected
 * conditions or bugs in the application. */
global trap_on_unexpected = 0;

global verbose = 0;

global expensive_checks = 0;

/* Number of detailed mutexes to report; sorted by total contention time.
 * This option is added to avoid too large N vale for -DMAX_ACTIONS=N as
 * well as too much noise in output.  */
global report_mutex_count = 10;

/* Number of detailed conditions to report; sorted by total wait time. */
global report_cond_count = 10;

/* Number of detailed read rwlocks to report; sorted by total wait time. */
global report_rdlock_count = 10;
/* Number of detailed write rwlocks to report; sorted by total wait time. */
global report_wrlock_count = 10;

/* Number of detailed spinlocks to report; sorted by total wait time. */
global report_spin_count = 10;

/* Number of detailed barriers to report; sorted by total wait time. */
global report_barrier_count = 10;

private global tid_to_thread;
private global thread_to_tid;
private global thread_name;

private global attr_init;

/* Explicit pthread_exit */
private global exited_tids;
/* Explicit pthread_join */
private global joined_tids;
/* Explicit pthread_cancel */
private global canceled_tids;
/* Kernel did terminate but still uncertain if process is exiting,
 * possibly due to a SIGTERM. In such case, do not cleanup all data
 * to avoid too many false positives about unexpected states. */
private global uncertain_tids;

private global mutexattr_init;

private global mutex_lock;
private global mutex_lock_count;
private global mutex_lock_entry;
private global mutex_lock_entry_timer;
private global mutex_consistent;
private global mutex_prioceiling;
private global mutex_init;

/* Sum of contention time from attempt to lock until getting the lock */
private global mutex_contention_total_time;
/* Minimum wait time to get the lock */
private global mutex_contention_min_time;
/* Maximum wait time to get the lock */
private global mutex_contention_max_time;
/* Number of successful locks */
private global mutex_contention_count;
/* Number of threads that did get the mutex lock */
private global mutex_contention_per_thread;
/* Number of failed trylock calls */
private global mutex_contention_fail_try;
/* Number of failed timedlock calls */
private global mutex_contention_fail_timed;
/* Sum of lock time from lock to unlock */
private global mutex_lock_total_time;
/* Minimum lock time */
private global mutex_lock_min_time;
/* Maximum lock time */
private global mutex_lock_max_time;

private global condattr_init;

private global conditions;
private global mutex_wait;
private global cond_wait;
private global cond_wait_timer;
private global cond_init;

/* Count of successful cond wait calls */
private global cond_wait_count;
/* Count of successful cond wait calls per thread */
private global cond_wait_per_thread;
/* Sum of total time waiting for a condition by all threads */
private global cond_wait_total_time;
/* Minimum time waiting for a condition by all threads */
private global cond_wait_min_time;
/* Maximum time waiting for a condition by all threads */
private global cond_wait_max_time;
/* Number of failed timed_cond_wait */
private global cond_wait_timedout;
private global cond_signal_count;
private global cond_signal_per_thread;
private global cond_broadcast_count;
private global cond_broadcast_per_thread;

private global rwlockattr_init;

private global rwlock_init;
private global rdlock_entry;
private global rdlock_entry_timer;
private global rdlocks;
private global wrlock_entry;
private global wrlock_entry_timer;
private global wrlocks;

private global rdlock_count;
private global rdlock_contention_total_time;
private global rdlock_contention_min_time;
private global rdlock_contention_max_time;
private global rdlock_contention_count;
private global rdlock_contention_per_thread;
private global rdlock_contention_fail_try;
private global rdlock_contention_fail_timed;
private global rdlock_total_time;
private global rdlock_min_time;
private global rdlock_max_time;
private global wrlock_count;
private global wrlock_contention_total_time;
private global wrlock_contention_min_time;
private global wrlock_contention_max_time;
private global wrlock_contention_count;
private global wrlock_contention_per_thread;
private global wrlock_contention_fail_try;
private global wrlock_contention_fail_timed;
private global wrlock_total_time;
private global wrlock_min_time;
private global wrlock_max_time;

private global spin_init;
private global spin_entry;
private global spinlocks;

private global spin_count;
private global spin_contention_total_time;
private global spin_contention_min_time;
private global spin_contention_max_time;
private global spin_contention_count;
private global spin_contention_per_thread;
private global spin_contention_fail_try;
private global spin_total_time;
private global spin_min_time;
private global spin_max_time;

private global barrierattr_init;

private global barrier_init;
private global barrier_entry;
private global barrier_count;
private global barriers;

private global barrier_contention_total_time;
private global barrier_contention_min_time;
private global barrier_contention_max_time;
private global barrier_contention_count;
private global barrier_contention_per_thread;

private global process_name = "";
private global process_path = "";
private global process_arguments, exec_process_arguments;

private global details;
private global details_thread_count;
private global details_signal_count;
private global details_broadcast_count;

/* If gdbserver does not work, you can try:
 * while test -z "$(pidof BINARY)"; do :; done; gdb -p $(pidof BINARY)
 */
global start_gdbserver = 0;
global gdbserver_port = 1234;
global binary_path_for_gdbserver = "";

// For RHEL8 use 2.28
// For RHEL9 use 2.34
@define GLIBC			%( "2.39" %)
%( @GLIBC < "2.34" %?
  @define PTHREAD_PATH		%( "/lib64/libpthread.so.0" %) %:
  @define PTHREAD_PATH		%( "/lib64/libc.so.6" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_attr_init	%( "__pthread_attr_init_2_1" %) %:
  @define _pthread_attr_init	%( "__pthread_attr_init" %) %)
@define	_pthread_attr_getaffinity	%( "__pthread_attr_getaffinity_new" %)
@define	_pthread_attr_getdetachstate	%( "__pthread_attr_getdetachstate" %)
%( @GLIBC == "2.34" %?
@define	_pthread_attr_getguardsize	%( "__pthread_attr_getguardsize" %) %:
@define	_pthread_attr_getguardsize	%( "pthread_attr_getguardsize" %) %)
@define	_pthread_attr_getinheritsched	%( "__pthread_attr_getinheritsched" %)
@define	_pthread_attr_getschedparam	%( "__pthread_attr_getschedparam" %)
@define	_pthread_attr_getschedpolicy	%( "__pthread_attr_getschedpolicy" %)
@define	_pthread_attr_getscope	%( "__pthread_attr_getstackaddr" %)	/* deprecated */
@define	_pthread_attr_getstack	%( "__pthread_attr_getstack" %)
@define	_pthread_attr_getstackaddr	%( "__pthread_attr_getstackaddr" %)
@define	_pthread_attr_getstacksize	%( "__pthread_attr_getstacksize" %)
@define	_pthread_attr_setaffinity	%( "__pthread_attr_setaffinity_np" %)
@define	_pthread_attr_setdetachstate	%( "__pthread_attr_setdetachstate" %)
%( @GLIBC == "2.34" %?
@define	_pthread_attr_setguardsize	%( "__pthread_attr_setguardsize" %) %:
@define	_pthread_attr_setguardsize	%( "pthread_attr_setguardsize" %) %)
@define	_pthread_attr_setinheritsched	%( "__pthread_attr_setinheritsched" %)
@define	_pthread_attr_setschedparam	%( "__pthread_attr_setschedparam" %)
@define	_pthread_attr_setschedpolicy	%( "__pthread_attr_setschedpolicy" %)
@define	_pthread_attr_setscope	%( "__pthread_attr_setstackaddr" %)	/* deprecated */
@define	_pthread_attr_setstack	%( "__pthread_attr_setstack" %)
@define	_pthread_attr_setstackaddr	%( "__pthread_attr_setstackaddr" %)
@define	_pthread_attr_setstacksize	%( "__pthread_attr_setstacksize" %)
@define	_pthread_attr_destroy	%( "__pthread_attr_destroy" %)
@define	_pthread_create		%( "__pthread_create_2_1" %)
%( @GLIBC < "2.34" %?
  @define _pthread_setname_np	%( "pthread_setname_np" %) %:
  @define _pthread_setname_np	%( "__pthread_setname_np" %) %)
@define	_pthread_cancel		%( "__pthread_cancel" %)
@define	_pthread_testcancel	%( "__pthread_testcancel" %)
%( @GLIBC < "2.34" %?
  @define _pthread_detach	%( "__pthread_detach" %) %:
  @define _pthread_detach	%( "___pthread_detach" %) %)
@define	_pthread_exit		%( "__pthread_exit" %)
%( @GLIBC < "2.34" %?
  @define _pthread_join		%( "__pthread_join" %) %:
  @define _pthread_join		%( "___pthread_join" %) %)
@define	_pthread_kill		%( "__pthread_kill" %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_init	%( "___pthread_mutexattr_init" %) %:
@define	_pthread_mutexattr_init	%( "__pthread_mutexattr_init" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_getprioceiling	%( "__pthread_mutexattr_getprioceiling" %) %:
@define	_pthread_mutexattr_getprioceiling	%( "pthread_mutexattr_getprioceiling" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_getprotocol	%( "__pthread_mutexattr_getprotocol" %) %:
@define	_pthread_mutexattr_getprotocol	%( "pthread_mutexattr_getprotocol" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_getpshared	%( "__pthread_mutexattr_getpshared" %) %:
@define	_pthread_mutexattr_getpshared	%( "pthread_mutexattr_getpshared" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_getrobust	%( "__pthread_mutexattr_getrobust" %) %:
@define	_pthread_mutexattr_getrobust	%( "pthread_mutexattr_getrobust" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_gettype	%( "__pthread_mutexattr_gettype" %) %:
@define	_pthread_mutexattr_gettype	%( "pthread_mutexattr_gettype" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_setprioceiling	%( "__pthread_mutexattr_setprioceiling" %) %:
@define	_pthread_mutexattr_setprioceiling	%( "pthread_mutexattr_setprioceiling" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_setprotocol	%( "__pthread_mutexattr_setprotocol" %) %:
@define	_pthread_mutexattr_setprotocol	%( "pthread_mutexattr_setprotocol" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_setpshared	%( "__pthread_mutexattr_setpshared" %) %:
@define	_pthread_mutexattr_setpshared	%( "pthread_mutexattr_setpshared" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_setrobust	%( "__pthread_mutexattr_setrobust" %) %:
@define	_pthread_mutexattr_setrobust	%( "pthread_mutexattr_setrobust" %) %)
@define	_pthread_mutexattr_settype	%( "pthread_mutexattr_settype" %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutexattr_destroy	%( "___pthread_mutexattr_destroy" %) %:
@define	_pthread_mutexattr_destroy	%( "__pthread_mutexattr_destroy" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutex_init	%( "___pthread_mutex_init" %) %:
@define	_pthread_mutex_init	%( "__pthread_mutex_init" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutex_trylock	%( "___pthread_mutex_trylock" %) %:
@define	_pthread_mutex_trylock	%( "__pthread_mutex_trylock" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_mutex_timedlock	%( "__pthread_mutex_timedlock" %) %:
  @define _pthread_mutex_timedlock	%( "___pthread_mutex_timedlock" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutex_lock	%( "___pthread_mutex_lock" %) %:
@define	_pthread_mutex_lock	%( "__pthread_mutex_lock" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_mutex_consistent	%( "pthread_mutex_consistent" %) %:
  @define _pthread_mutex_consistent	%( "__pthread_mutex_consistent" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_mutex_getprioceiling	%( "pthread_mutex_getprioceiling" %) %:
  @define _pthread_mutex_getprioceiling	%( "__pthread_mutex_getprioceiling" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_mutex_setprioceiling	%( "pthread_mutex_setprioceiling" %) %:
  @define _pthread_mutex_setprioceiling	%( "__pthread_mutex_setprioceiling" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutex_unlock	%( "___pthread_mutex_unlock" %) %:
@define	_pthread_mutex_unlock	%( "__pthread_mutex_unlock" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_mutex_destroy	%( "___pthread_mutex_destroy" %) %:
@define	_pthread_mutex_destroy	%( "__pthread_mutex_destroy" %) %)
@define	_pthread_condattr_init	%( "__pthread_condattr_init" %)
%( @GLIBC == "2.34" %?
@define	_pthread_condattr_getclock	%( "__pthread_condattr_getclock" %) %:
@define	_pthread_condattr_getclock	%( "pthread_condattr_getclock" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_condattr_getpshared	%( "__pthread_condattr_getpshared" %) %:
@define	_pthread_condattr_getpshared	%( "pthread_condattr_getpshared" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_condattr_setclock	%( "__pthread_condattr_setclock" %) %:
@define	_pthread_condattr_setclock	%( "pthread_condattr_setclock" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_condattr_setpshared	%( "__pthread_condattr_setpshared" %) %:
@define	_pthread_condattr_setpshared	%( "pthread_condattr_setpshared" %) %)
@define	_pthread_condattr_destroy	%( "__pthread_condattr_destroy" %)
@define	_pthread_cond_init	%( "__pthread_cond_init" %)
%( @GLIBC < "2.34" %?
  @define _pthread_cond_broadcast	%( "__pthread_cond_broadcast" %) %:
  @define _pthread_cond_broadcast	%( "___pthread_cond_broadcast" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_cond_signal	%( "__pthread_cond_signal" %) %:
  @define _pthread_cond_signal	%( "___pthread_cond_signal" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_cond_wait	%( "__pthread_cond_wait" %) %:
  @define _pthread_cond_wait	%( "___pthread_cond_wait" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_cond_timedwait	%( "__pthread_cond_timedwait" %) %:
  @define _pthread_cond_timedwait	%( "___pthread_cond_timedwait" %) %)
@define	_pthread_cond_destroy	%( "__pthread_cond_destroy" %)
%( @GLIBC < "2.34" %?
  @define _pthread_rwlockattr_init	%( "pthread_rwlockattr_init" %) %:
  @define _pthread_rwlockattr_init	%( "__pthread_rwlockattr_init" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_rwlockattr_getpshared	%( "pthread_rwlockattr_getpshared" %) %:
  @define _pthread_rwlockattr_getpshared	%( "__pthread_rwlockattr_getpshared" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_rwlockattr_setpshared	%( "pthread_rwlockattr_setpshared" %) %:
  @define _pthread_rwlockattr_setpshared	%( "__pthread_rwlockattr_setpshared" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_rwlockattr_destroy	%( "pthread_rwlockattr_destroy" %) %:
  @define _pthread_rwlockattr_destroy	%( "__pthread_rwlockattr_destroy" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_rwlock_init	%( "___pthread_rwlock_init" %) %:
@define	_pthread_rwlock_init	%( "__pthread_rwlock_init" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_rwlock_rdlock	%( "___pthread_rwlock_rdlock" %) %:
@define	_pthread_rwlock_rdlock	%( "__pthread_rwlock_rdlock" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_rwlock_tryrdlock	%( "___pthread_rwlock_tryrdlock" %) %:
@define	_pthread_rwlock_tryrdlock	%( "__pthread_rwlock_tryrdlock" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_rwlock_timedrdlock	%( "pthread_rwlock_timedrdlock" %) %:
  @define _pthread_rwlock_timedrdlock	%( "___pthread_rwlock_timedrdlock" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_rwlock_wrlock	%( "___pthread_rwlock_wrlock" %) %:
@define	_pthread_rwlock_wrlock	%( "__pthread_rwlock_wrlock" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_rwlock_trywrlock	%( "___pthread_rwlock_trywrlock" %) %:
@define	_pthread_rwlock_trywrlock	%( "__pthread_rwlock_trywrlock" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_rwlock_timedwrlock	%( "pthread_rwlock_timedwrlock" %) %:
  @define _pthread_rwlock_timedwrlock	%( "___pthread_rwlock_timedwrlock" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_rwlock_unlock	%( "___pthread_rwlock_unlock" %) %:
@define	_pthread_rwlock_unlock	%( "__pthread_rwlock_unlock" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_rwlock_destroy	%( "___pthread_rwlock_destroy" %) %:
@define	_pthread_rwlock_destroy	%( "__pthread_rwlock_destroy" %) %)
@define	_pthread_spin_init	%( "pthread_spin_init" %)
%( @GLIBC < "2.34" %?
  @define _pthread_spin_lock	%( "pthread_spin_lock" %) %:
  @define _pthread_spin_lock	%( "__pthread_spin_lock" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_spin_trylock	%( "pthread_spin_trylock" %) %:
  @define _pthread_spin_trylock	%( "__pthread_spin_trylock" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_spin_unlock	%( "pthread_spin_unlock" %) %:
  @define _pthread_spin_unlock	%( "__pthread_spin_unlock" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_spin_destroy	%( "pthread_spin_destroy" %) %:
  @define _pthread_spin_destroy	%( "__pthread_spin_destroy" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_barrierattr_init	%( "__pthread_barrierattr_init" %) %:
@define	_pthread_barrierattr_init	%( "pthread_barrierattr_init" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_barrierattr_getpshared	%( "__pthread_barrierattr_getpshared" %) %:
@define	_pthread_barrierattr_getpshared	%( "pthread_barrierattr_getpshared" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_barrierattr_setpshared	%( "__pthread_barrierattr_setpshared" %) %:
@define	_pthread_barrierattr_setpshared	%( "pthread_barrierattr_setpshared" %) %)
%( @GLIBC == "2.34" %?
@define	_pthread_barrierattr_destroy	%( "__pthread_barrierattr_destroy" %) %:
@define	_pthread_barrierattr_destroy	%( "pthread_barrierattr_destroy" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_barrier_init	%( "__pthread_barrier_init" %) %:
  @define _pthread_barrier_init	%( "___pthread_barrier_init" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_barrier_wait	%( "__pthread_barrier_wait" %) %:
  @define _pthread_barrier_wait	%( "___pthread_barrier_wait" %) %)
%( @GLIBC < "2.34" %?
  @define _pthread_barrier_destroy	%( "pthread_barrier_destroy" %) %:
  @define _pthread_barrier_destroy	%( "__pthread_barrier_destroy" %) %)


@define	PTHREAD_BARRIER_SERIAL_THREAD %( -1 %)
@define	EPERM			%(   1 %)
@define EAGAIN			%(  11 %)
@define	EBUSY			%(  16 %)
@define EINVAL			%(  22 %)
@define	EDEADLK			%(  35 %)
@define EOPNOTSUPP		%(  95 %)
@define	ETIMEDOUT		%( 110 %)
@define	EOWNERDEAD		%( 130 %)
@define	ENOTRECOVERABLE		%( 131 %)

private global _arg1;
private global _arg2;
private global _arg3;
private global _return;
@define ARG1			%( @defined($arg1) ? $arg1 : register(_arg1) %)
@define ENTRY_ARG1		%( @defined(@entry($arg1)) ? @entry($arg1) : @entry(register(_arg1)) %)
@define ARG2			%( @defined($arg2) ? $arg2 : register(_arg2) %)
@define ENTRY_ARG2		%( @defined(@entry($arg2)) ? @entry($arg2) : @entry(register(_arg2)) %)
@define ARG3			%( @defined($arg3) ? $arg3 : register(_arg3) %)
@define ENTRY_ARG3		%( @defined(@entry($arg3)) ? @entry($arg3) : @entry(register(_arg3)) %)
@define RETURN			%( @defined($return) ? $return : register(_return) %)

probe begin {
    /* Make it easier to attach gdb to the proper process, if it is run
     * by some wrapper script or exec'ed (e.g. env ENV=val binary).
     * Note that full path is expected to specified here. */
    %( $# >= 1 %?
      if (start_gdbserver)
	  binary_path_for_gdbserver = @1;
	  %)

    tokenize(cmdline_str(), " ");
    token = tokenize("", " ");
    if (token != "-c")
	error(sprintf("Failed to tokenize command line.\n"
		      "Cannot run system wide. "
		      "Must use '-c CMD''.\n"
		      "cmdline_str() returns <%s>\n",
		      cmdline_str()));
    if (start_gdbserver && binary_path_for_gdbserver == "")
	error("When starting gdb_server must specify the binary path.\n"
	      "Example: stap OPTS -c \"CMD\" /binary/path/for/gdbserver\n");

    /* No setting to "only" trap on specific error */
    if (trap_on_ownerdead == -1)
	trap_on_ownerdead = trap_on_all_errors;
    if (trap_on_timedout == -1)
	trap_on_timedout = trap_on_all_errors;
    if (trap_on_busy == -1)
	trap_on_busy = trap_on_all_errors;
    if (trap_on_again == -1)
	trap_on_again = trap_on_all_errors;
    %( arch == "x86_64" %?
      _arg1 = "rdi";
      _arg2 = "rsi";
      _arg3 = "rdx";
      _return = "rax"
      %: %( arch == "arm64" %?
	   _arg1 = "x0";
	   _arg2 = "x1";
	   _arg3 = "x2";
	   _return = "x0"
	   %: %( arch == "powerpc" %?
		_arg1 = "r3";
		_arg2 = "r4";
		_arg3 = "r5";
		_return = "r3"
		%: error("unsupported architecture")
		%)
	   %)
      %);
    printf("Stap ready.\n");
}

function run_gdbserver(pid) {
    system(sprintf("gdbserver --attach :%d %d",
		   gdbserver_port, pid));
    printf("To attach gdb, run in the command line\n$ gdb %s\n",
	   process_path);
    printf("In gdb prompt type:\n(gdb) target remote :%d\n\n",
	   gdbserver_port);
}

function report_error(where:string, errno:long) {
    if ((errno == @EOWNERDEAD && !trap_on_ownerdead) ||
	(errno == @ETIMEDOUT && !trap_on_timedout) ||
	(errno == @EBUSY && !trap_on_busy) ||
	(errno == @EAGAIN && !trap_on_again) ||
	!errno || !trap_on_all_errors)
	return;
    printf("%s error: %s\n", where, errno_str(errno));
    print_ubacktrace();
    %(guru_mode != 0 %?
      raise(%{ SIGTRAP %}) %: printf("generating SIGTRAP needs guru mode\n")
	  %);
}

function unexpected_condition(variable:string, tid:long, pointer:long,
			      destroyed:long) {
    printf("Unexpected %s[%ld, %p] %s\n", variable, tid, pointer,
	   destroyed ? "already destroyed" : "still initialized");
    if (trap_on_unexpected)
	%(guru_mode != 0 %?
	  raise(%{ SIGTRAP %}) %:
	  printf("generating SIGTRAP needs guru mode\n")
	  %);
}

function possibly_double_unlock(func:string, type:string,
				tid:long, pointer:long) {
    printf("Unexpected call to %s, with tid %ld and %s %p. Called twice?",
	   func, tid, type, pointer);
    print_ubacktrace();
    if (trap_on_unexpected)
	%(guru_mode != 0 %?
	  raise(%{ SIGTRAP %}) %:
	  printf("generating SIGTRAP needs guru mode\n")
	  %);
}

function possibly_double_destroy(func:string, type:string, pointer:long) {
    printf("Unexpected call to %s, with %s %p. Called twice?",
	   func, type, pointer);
    print_ubacktrace();
    if (trap_on_unexpected)
	%(guru_mode != 0 %?
	  raise(%{ SIGTRAP %}) %:
	  printf("generating SIGTRAP needs guru mode\n")
	  %);
}

probe
process(@PTHREAD_PATH).function(@_pthread_attr_init).return
{
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr	= @ENTRY_ARG1;
	check_memory_reuse(attr, "attr");
	attr_init[attr] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_attr_getaffinity).return,
process(@PTHREAD_PATH).function(@_pthread_attr_getdetachstate).return,
process(@PTHREAD_PATH).function(@_pthread_attr_getguardsize).return,
process(@PTHREAD_PATH).function(@_pthread_attr_getinheritsched).return,
process(@PTHREAD_PATH).function(@_pthread_attr_getschedparam).return,
process(@PTHREAD_PATH).function(@_pthread_attr_getschedpolicy).return,
process(@PTHREAD_PATH).function(@_pthread_attr_getscope).return,
process(@PTHREAD_PATH).function(@_pthread_attr_getstackaddr).return,
process(@PTHREAD_PATH).function(@_pthread_attr_getstack).return,
process(@PTHREAD_PATH).function(@_pthread_attr_getstacksize).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setaffinity).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setdetachstate).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setguardsize).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setinheritsched).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setschedparam).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setschedpolicy).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setscope).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setstackaddr).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setstack).return,
process(@PTHREAD_PATH).function(@_pthread_attr_setstacksize).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
    }
    else
	report_error(ppfunc(), result);
}

/*
function
forget_attr(attr) {
}
 */

probe
process(@PTHREAD_PATH).function(@_pthread_attr_destroy).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr  = @ENTRY_ARG1;
	if (attr_init[attr] == -1) {
	    backtrace = sprint_ubacktrace();
	    /* if attr is NULL a default one is used. */
	    if (backtrace =~ "pthread_create@@GLIBC")
		next;
	    possibly_double_destroy("pthread_attr_destroy",
				    "attr", attr);
	}
	else
	    attr_init[attr] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_create).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	//thread	= @ENTRY_ARG1;
	/*
	attr	= @ENTRY_ARG2;
	routine	= @ENTRY_ARG3;
	arg	= @ENTRY_ARG4;
	 */
	/*
	struct pthread {
	    union {
	        tcbhead_t header;		sizeof(tcbhead_t) = 704
	        void *__padding[24];
	    };
	    list_t list;			sizeof(list_t) = 16
	    pid_t tid;
	    ...
	 }
	 */
	 /* This looks too fragile */
	/*
	pthread = user_int64(thread);
	tid = user_int32(pthread + 720);
	tid_to_thread[tid] = thread;
	*/
    }
    else
	report_error(ppfunc(), result);
}
/* Use "mark" instead of too fragile offset computation as example above. */
probe
process(@PTHREAD_PATH).mark("pthread_start") {
    if (pid() != target())
	next;
    thread	= $arg1;
    /*
    routine	= $arg2;
    arg		= $arg3;
     */
    check_memory_reuse(thread, "thread");
    tid_to_thread[tid()] = thread;
    thread_to_tid[thread] = tid();
}

probe
process(@PTHREAD_PATH).function(@_pthread_setname_np).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	thread	= @ENTRY_ARG1;
	name	= @ENTRY_ARG2;
	if (verbose)
	    thread_name[thread] = user_string(name);
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_cancel).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	thread = @ENTRY_ARG1;
	canceled_tids[thread_to_tid[thread]] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

/*
probe
process(@PTHREAD_PATH).function(@_pthread_testcancel) {
    if (pid() != target())
	next;
}
 */

probe
process(@PTHREAD_PATH).function(@_pthread_detach).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	// thread = @ENTRY_ARG1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_exit) {
    if (pid() != target())
	next;
    thread = tid_to_thread[tid()];
    delete tid_to_thread[tid()];
    delete thread_to_tid[thread];
    if (verbose)
	delete thread_name[thread];
    exited_tids[tid()] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_join).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	thread = @ENTRY_ARG1;
	tid = thread_to_tid[thread];
	delete tid_to_thread[tid];
	delete thread_to_tid[thread];
	if (verbose)
	    delete thread_name[thread];
	joined_tids[tid()] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_kill).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	// thread = @ENTRY_ARG1;
	// signal = @ENTRY_ARG2;
    }
    else
	report_error(ppfunc(), result);
}

function
unexpected_deleting_detail(tid) {
    printf("Deleting tid %ld", tid);
    if (verbose)
	printf(" thread %p", tid_to_thread[tid]);
    printf(". ");
}

function
forget_tid_mutexes(tid, actually_expected) {
    if (expensive_checks) {
	foreach([key, mutex] in mutex_lock_entry) {
	    if (key == tid)
		details_thread_count[mutex] = 1;
	}
	foreach (mutex in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("mutex_lock_entry",
				     tid, mutex, mutex_init[mutex] == -1);
	    }
	    delete mutex_lock_entry[tid, mutex];
	}
	delete details_thread_count;
	foreach([key, mutex] in mutex_lock_entry_timer) {
	    if (key == tid)
		details_thread_count[mutex] = 1;
	}
	foreach (mutex in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("mutex_lock_entry_timer",
				     tid, mutex, mutex_init[mutex] == -1);
	    }
	    delete mutex_lock_entry_timer[tid, mutex];
	}
	delete details_thread_count;
    }
    if (verbose) {
	foreach([key, mutex] in mutex_contention_per_thread) {
	    if (key == tid)
		details_thread_count[mutex] = 1;
	}
	foreach (mutex in details_thread_count) {
	    delete mutex_contention_per_thread[tid, mutex];
	}
	delete details_thread_count;
    }
}

function
forget_tid_conds(tid, actually_expected) {
    if (expensive_checks) {
	foreach([key, cond] in cond_wait) {
	    if (key == tid)
		details_thread_count[cond] = 1;
	}
	foreach (cond in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("cond_wait",
				     tid, cond, cond_init[cond] == -1);
	    }
	    delete cond_wait[tid, cond];
	}
	delete details_thread_count;
	foreach([key, mutex] in mutex_wait) {
	    if (key == tid)
		details_thread_count[mutex] = 1;
	}
	foreach (mutex in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("mutex_wait",
				     tid, mutex, mutex_init[mutex] == -1);
	    }
	    delete mutex_wait[tid, mutex];
	}
	delete details_thread_count;
	foreach([key, cond] in cond_wait_timer) {
	    if (key == tid)
		details_thread_count[cond] = 1;
	}
	foreach (cond in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("cond_wait_timer",
				     tid, cond, cond_init[cond] == -1);
	    }
	    delete cond_wait_timer[tid, cond];
	}
	delete details_thread_count;
    }
    if (verbose) {
	foreach([key, cond] in cond_broadcast_per_thread) {
	    if (key == tid)
		details_thread_count[cond] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete cond_broadcast_per_thread[tid, cond];
	}
	delete details_thread_count;
	foreach([key, cond] in cond_signal_per_thread) {
	    if (key == tid)
		details_thread_count[cond] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete cond_signal_per_thread[tid, cond];
	}
	delete details_thread_count;
	foreach([key, cond] in cond_wait_per_thread) {
	    if (key == tid)
		details_thread_count[cond] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete cond_wait_per_thread[tid, cond];
	}
	delete details_thread_count;
    }
}

function
forget_tid_rdlocks(tid, actually_expected) {
    if (expensive_checks) {
	foreach([key, rwlock] in rdlock_entry) {
	    if (key == tid)
		details_thread_count[rwlock] = 1;
	}
	foreach (rwlock in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("rdlock_entry",
				     tid, rwlock, rwlock_init[rwlock] == -1);
	    }
	    delete rdlock_entry[tid, rwlock];
	}
	delete details_thread_count;
	foreach([key, rwlock] in rdlock_entry_timer) {
	    if (key == tid)
		details_thread_count[rwlock] = 1;
	}
	foreach (rwlock in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("rdlock_entry_timer",
				     tid, rwlock, rwlock_init[rwlock] == -1);
	    }
	    delete rdlock_entry_timer[tid, rwlock];
	}
	delete details_thread_count;
    }
    if (verbose) {
	foreach([key, rwlock] in rdlock_contention_per_thread) {
	    if (key == tid)
		details_thread_count[rwlock] = 1;
	}
	foreach (rwlock in details_thread_count) {
	    delete rdlock_contention_per_thread[tid, rwlock];
	}
	delete details_thread_count;
    }
}

function
forget_tid_wrlocks(tid, actually_expected) {
    if (expensive_checks) {
	foreach([key, rwlock] in wrlock_entry) {
	    if (key == tid)
		details_thread_count[rwlock] = 1;
	}
	foreach (rwlock in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("wrlock_entry",
				     tid, rwlock, rwlock_init[rwlock] == -1);
	    }
	    delete wrlock_entry[tid, rwlock];
	}
	delete details_thread_count;
	foreach([key, rwlock] in wrlock_entry_timer) {
	    if (key == tid)
		details_thread_count[rwlock] = 1;
	}
	foreach (rwlock in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("wrlock_entry_timer",
				     tid, rwlock, rwlock_init[rwlock] == -1);
	    }
	    delete wrlock_entry_timer[tid, rwlock];
	}
	delete details_thread_count;
    }
    if (verbose) {
	foreach([key, rwlock] in wrlock_contention_per_thread) {
	    if (key == tid)
		details_thread_count[rwlock] = 1;
	}
	foreach (rwlock in details_thread_count) {
	    delete wrlock_contention_per_thread[tid, rwlock];
	}
	delete details_thread_count;
    }
}

function
forget_tid_spins(tid, actually_expected) {
    if (expensive_checks) {
	foreach([key, spin] in spin_entry) {
	    if (key == tid)
		details_thread_count[spin] = 1;
	}
	foreach (spin in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("spin_entry",
				     tid, spin, spin_init[spin] == -1);
	    }
	    delete spin_entry[tid, spin];
	}
	delete details_thread_count;
    }
    if (verbose) {
	foreach([key, spin] in spin_contention_per_thread) {
	    if (key == tid)
		details_thread_count[spin] = 1;
	}
	foreach (spin in details_thread_count) {
	    delete spin_contention_per_thread[tid, spin];
	}
	delete details_thread_count;
    }
}

function
forget_tid_barriers(tid, actually_expected) {
    if (expensive_checks) {
	foreach([key, barrier] in barrier_entry) {
	    if (key == tid)
		details_thread_count[barrier] = 1;
	}
	foreach (barrier in details_thread_count) {
	    if (!actually_expected) {
		unexpected_deleting_detail(tid);
		unexpected_condition("barrier_entry",
				     tid, barrier, barrier_init[barrier] == -1);
	    }
	    delete barrier_entry[tid, barrier];
	}
	delete details_thread_count;
    }
    if (verbose) {
	foreach([key, barrier] in barrier_contention_per_thread) {
	    if (key == tid)
		details_thread_count[barrier] = 1;
	}
	foreach (barrier in details_thread_count) {
	    delete barrier_contention_per_thread[tid, barrier];
	}
	delete details_thread_count;
    }
}

function
forget_tid(tid, force) {
    if (exited_tids[tid])
	delete exited_tids[tid];
    else if (joined_tids[tid])
	delete joined_tids[tid];
    else if (canceled_tids[tid])
	delete canceled_tids[tid];
    else if (!force)
	return 0;
    delete thread_to_tid[tid_to_thread[tid]];
    if (verbose)
	delete thread_name[tid_to_thread[tid]];
    actually_expected = !!uncertain_tids[tid];
    forget_tid_mutexes(tid, actually_expected);
    forget_tid_conds(tid, actually_expected);
    forget_tid_rdlocks(tid, actually_expected);
    forget_tid_wrlocks(tid, actually_expected);
    forget_tid_spins(tid, actually_expected);
    forget_tid_barriers(tid, actually_expected);
    delete tid_to_thread[tid];
    return 1;
}

probe
kprocess.release {
    if (pid() != target())
	next;
    /* If reused and new instance is exiting. */
    force = uncertain_tids[released_tid];
    uncertain = forget_tid(released_tid, force) == 0;
    now = gettimeofday_us();
    foreach (tid in uncertain_tids) {
	/* Auto remove from list if exited 30 or more seconds ago */
	if (now - uncertain_tids[tid] > 1000000 * 30) {
	    details_thread_count[tid] = 1;
	    forget_tid(tid, 1);
	}
    }
    foreach (tid in details_thread_count)
	delete uncertain_tids[tid];
    delete details_thread_count;
    if (uncertain)
	uncertain_tids[released_tid] = now;
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutexattr_init).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr	= @ENTRY_ARG1;
	check_memory_reuse(attr, "mutexattr");
	mutexattr_init[attr] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutexattr_getprioceiling).return,
process(@PTHREAD_PATH).function(@_pthread_mutexattr_getprotocol).return,
process(@PTHREAD_PATH).function(@_pthread_mutexattr_getpshared).return,
process(@PTHREAD_PATH).function(@_pthread_mutexattr_getrobust).return,
process(@PTHREAD_PATH).function(@_pthread_mutexattr_gettype).return,
process(@PTHREAD_PATH).function(@_pthread_mutexattr_setprioceiling).return,
process(@PTHREAD_PATH).function(@_pthread_mutexattr_setprotocol).return,
process(@PTHREAD_PATH).function(@_pthread_mutexattr_setpshared).return,
process(@PTHREAD_PATH).function(@_pthread_mutexattr_setrobust).return,
process(@PTHREAD_PATH).function(@_pthread_mutexattr_gettype).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
    }
    else
	report_error(ppfunc(), result);
}

/*
function
forget_mutexattr(attr) {
}
 */

probe
process(@PTHREAD_PATH).function(@_pthread_mutexattr_destroy).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr  = @ENTRY_ARG1;
	if (mutexattr_init[attr] == -1)
	    possibly_double_destroy("pthread_mutexattr_destroy",
				    "mutexattr", attr);
	else
	    mutexattr_init[attr] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_init).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	mutex = @ENTRY_ARG1;
	/*
	attr  = @ENTRY_ARG2;
	 */
	check_memory_reuse(mutex, "mutex");
	mutex_init[mutex] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

function common_mutex_lock(mutex, istry, tmout, result) {
    if (result == 0) {
	if ((++mutex_lock_count[mutex]) == 1) {
	    mutex_lock[mutex] = tid();
	    now = gettimeofday_us();
	    if (verbose) {
		diff = now - mutex_lock_entry[tid(), mutex];
		mutex_contention_total_time[mutex] += diff;
		if (!mutex_contention_min_time[mutex] ||
		    mutex_contention_min_time[mutex] > diff)
		    mutex_contention_min_time[mutex] = diff;
		if (mutex_contention_max_time[mutex] < diff)
		    mutex_contention_max_time[mutex] = diff;
		++mutex_contention_count[mutex];
		++mutex_contention_per_thread[tid(), mutex];
	    }
	    mutex_lock_entry[tid(), mutex] = now;
	}
    }
    else {
	report = 1;
	/* EAGAIN is returned if the counter wrapers around */
	if (istry) {
	    if (verbose)
		++mutex_contention_fail_try[mutex];
	    report = !trap_on_expected_busy || result != @EBUSY;
	}
	else if (tmout) {
	    if (verbose)
		++mutex_contention_fail_timed[mutex];
	    report = !trap_on_expected_timedout || result != @ETIMEDOUT;
	    delete mutex_lock_entry_timer[tid(), mutex];
	}
	if (report)
	    report_error(ppfunc(), result);
	delete mutex_lock_entry[tid(), mutex];
    }
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_trylock) {
    if (pid() != target())
	next;
    mutex = @ARG1;
    mutex_lock_entry[tid(), mutex] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_trylock).return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    common_mutex_lock(mutex, 1, 0, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_timedlock) {
    if (pid() != target())
	next;
    mutex = @ARG1;
    tmout = @ARG2;
    mutex_lock_entry[tid(), mutex] = gettimeofday_us();
    mutex_lock_entry_timer[tid(), mutex] = tmout;
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_timedlock).return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    tmout = @ENTRY_ARG2;
    common_mutex_lock(mutex, 0, tmout, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_lock) {
    if (pid() != target())
	next;
    mutex = @ARG1;
    mutex_lock_entry[tid(), mutex] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_lock).return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    common_mutex_lock(mutex, 0, 0, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_consistent).return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    if (result)
	report_error(ppfunc(), result);
    /* Record it is now consistent. Error state is -1. */
    mutex_consistent[mutex] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_getprioceiling).return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    ceiling = @ENTRY_ARG2;
    if (result)
	report_error(ppfunc(), result);
    else if (!mutex_prioceiling[mutex])
	mutex_prioceiling[mutex] = user_int32(ceiling);
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_setprioceiling).return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    new_ceiling = @ENTRY_ARG2;
    /*
    old_ceiling = @ENTRY_ARG3;
     */
    if (result)
	report_error(ppfunc(), result);
    else
	mutex_prioceiling[mutex] = new_ceiling;
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_unlock).return {
    if (pid() != target())
	next;
    result = @RETURN;
    mutex = @ENTRY_ARG1;
    if (result)
	report_error(ppfunc(), result);
    else {
	if (--mutex_lock_count[mutex] == 0) {
	    now = gettimeofday_us();
	    if (verbose) {
		diff = now - mutex_lock_entry[tid(), mutex];
		mutex_lock_total_time[mutex] += diff;
		if (!mutex_lock_min_time[mutex] ||
		    mutex_lock_min_time[mutex] > diff)
		    mutex_lock_min_time[mutex] = diff;
		if (mutex_lock_max_time[mutex] < diff)
		    mutex_lock_max_time[mutex] = diff;
	    }
	    /* mutex_lock_count and mutex_lock_per_thread would be basically
	     * the same as mutex_contention_*, not counting pending or active
	     * locks. */
	    delete mutex_lock[mutex];
	    delete mutex_lock_entry[tid(), mutex];
	    delete mutex_lock_entry_timer[tid(), mutex];
	    delete mutex_lock_count[mutex];
	}
	else if (mutex_lock_count[mutex] < 0) {
	    possibly_double_unlock("pthread_mutex_unlock", "mutex",
				   tid(), mutex);
	    next;
	}
    }
}

function
forget_mutex(mutex) {
    delete mutex_lock[mutex];
    if (expensive_checks) {
	destroyed = mutex_init[mutex] == -1;
	foreach ([tid, key] in mutex_lock_entry) {
	    if (key == mutex)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("mutex_lock_entry",
				 tid, mutex, destroyed);
	    delete mutex_lock_entry[tid, mutex];
	}
	delete details_thread_count;
	foreach ([tid, key] in mutex_lock_entry_timer) {
	    if (key == mutex)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("mutex_lock_entry_timer",
				 tid, mutex, destroyed);
	    delete mutex_lock_entry_timer[tid, mutex];
	}
	delete details_thread_count;
    }
    delete mutex_lock_count[mutex];
    if (verbose) {
	delete mutex_contention_total_time[mutex];
	delete mutex_contention_min_time[mutex];
	delete mutex_contention_max_time[mutex];
	delete mutex_contention_count[mutex];
	foreach ([tid, key] in mutex_contention_per_thread) {
	    if (key == mutex)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete mutex_contention_per_thread[tid, mutex];
	}
	delete details_thread_count;
	delete mutex_contention_fail_try[mutex];
	delete mutex_contention_fail_timed[mutex];
	delete mutex_lock_total_time[mutex];
	delete mutex_lock_min_time[mutex];
	delete mutex_lock_max_time[mutex];
    }
}

probe
process(@PTHREAD_PATH).function(@_pthread_mutex_destroy).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	mutex = @ENTRY_ARG1;
	if (mutex_init[mutex] == -1)
	    possibly_double_destroy("pthread_mutex_destroy",
				    "mutex", mutex);
	else
	    mutex_init[mutex] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_condattr_init).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr	= @ENTRY_ARG1;
	check_memory_reuse(attr, "condattr");
	condattr_init[attr] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_condattr_getclock).return,
process(@PTHREAD_PATH).function(@_pthread_condattr_getpshared).return,
process(@PTHREAD_PATH).function(@_pthread_condattr_setclock).return,
process(@PTHREAD_PATH).function(@_pthread_condattr_setpshared).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
    }
    else
	report_error(ppfunc(), result);
}

/*
function
forget_condattr(attr) {
}
 */

probe
process(@PTHREAD_PATH).function(@_pthread_condattr_destroy).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr	= @ENTRY_ARG1;
	if (mutexattr_init[attr] == -1)
	    possibly_double_destroy("pthread_condattr_destroy",
				    "condattr", attr);
	else
	    condattr_init[attr] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_cond_init).return {
    if (pid() != target())
	next;
    result = @RETURN;
    /*
    attr = @ENTRY_ARG2;
     */
    if (result == 0) {
	cond = @ENTRY_ARG1;
	check_memory_reuse(cond, "cond");
	cond_init[cond] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_cond_broadcast).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	cond = @ENTRY_ARG1;
	if (verbose) {
	    ++cond_broadcast_count[cond];
	    ++cond_broadcast_per_thread[tid(), cond];
	}
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_cond_signal).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	cond = @ENTRY_ARG1;
	if (verbose) {
	    ++cond_signal_count[cond];
	    ++cond_signal_per_thread[tid(), cond];
	}
    }
    else
	report_error(ppfunc(), result);
}

function
common_cond_wait_call(cond, mutex, tmout) {
    cond_wait[tid(), cond] = gettimeofday_us();
    if (tmout)
	cond_wait_timer[tid(), cond] = tmout;
    if (expensive_checks) {
	foreach ([tid, key] in mutex_wait) {
	    value = mutex_wait[tid, key];
	    if (key == cond && value != mutex) {
		printf("Multiple mutexes used on call to pthead_cond_wait, "
		       " prevously %p and now %p\n", value, mutex);
		print_ubacktrace();
		break;
	    }
	}
    }
    mutex_wait[tid(), cond] = mutex;
}

function
common_cond_wait_return(cond, mutex, tmout, result) {
    report = !!result;
    if (result) {
	if (tmout && result == @ETIMEDOUT) {
	    if (verbose)
		++cond_wait_timedout[cond];
	    report = trap_on_expected_timedout;
	}
	if (report)
	    report_error(ppfunc(), result);
    }
    if (verbose) {
	now = gettimeofday_us();
	diff = now - cond_wait[tid(), cond];
	++cond_wait_count[cond];
	cond_wait_total_time[cond] += diff;
	if (!cond_wait_min_time[cond] || cond_wait_min_time[cond] > diff)
	    cond_wait_min_time[cond] = diff;
	if (cond_wait_max_time[cond] < diff)
	    cond_wait_max_time[cond] = diff;
	if (!report)
	    ++cond_wait_per_thread[tid(), cond];
    }
    delete cond_wait[tid(), cond];
    delete mutex_wait[tid(), cond];
    if (tmout)
	delete cond_wait_timer[tid(), cond];
}

probe
process(@PTHREAD_PATH).function(@_pthread_cond_wait) {
    if (pid() != target())
	next;
    cond  = @ARG1;
    mutex = @ARG2;
    common_cond_wait_call(cond, mutex, 0);
}

probe
process(@PTHREAD_PATH).function(@_pthread_cond_wait).return {
    if (pid() != target())
	next;
    result = @RETURN;
    cond  = @ENTRY_ARG1;
    mutex = @ENTRY_ARG2;
    common_cond_wait_return(cond, mutex, 0, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_cond_timedwait) {
    if (pid() != target())
	next;
    cond  = @ARG1;
    mutex = @ARG2;
    tmout = @ARG3;
    common_cond_wait_call(cond, mutex, tmout);
}

probe
process(@PTHREAD_PATH).function(@_pthread_cond_timedwait).return {
    if (pid() != target())
	next;
    result = @RETURN;
    cond  = @ENTRY_ARG1;
    mutex = @ENTRY_ARG2;
    tmout = @ENTRY_ARG3;
    common_cond_wait_return(cond, mutex, tmout, result);
}

function
forget_condition(cond) {
    if (expensive_checks) {
	destroyed = cond_init[cond] == -1;
	/* These might only hold data on error/debug conditions */
	foreach ([tid, key] in cond_wait) {
	    if (key == cond)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("cond_wait", tid, cond, destroyed);
	    delete cond_wait[tid, cond];
	}
	delete details_thread_count;
	foreach ([tid, key] in mutex_wait) {
	    if (key == cond)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("mutex_wait", tid, cond, destroyed);
	    delete mutex_wait[tid, cond];
	}
	delete details_thread_count;
	foreach ([tid, key] in cond_wait_timer) {
	    if (key == cond)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("cond_wait_timer", tid, cond, destroyed);
	    delete cond_wait_timer[tid, cond];
	}
	delete details_thread_count;
    }
    if (verbose) {
	delete cond_broadcast_count[cond];
	foreach ([tid, key] in cond_broadcast_per_thread) {
	    if (key == cond)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete cond_broadcast_per_thread[tid, cond];
	}
	delete details_thread_count;
	delete cond_signal_count[cond];
	foreach ([tid, key] in cond_signal_per_thread) {
	    if (key == cond)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete cond_signal_per_thread[tid, cond];
	}
	delete details_thread_count;
	delete cond_wait_timedout[cond];
	delete cond_wait_count[cond];
	delete cond_wait_total_time[cond];
	delete cond_wait_min_time[cond];
	delete cond_wait_max_time[cond];
	foreach ([tid, key] in cond_wait_per_thread) {
	    if (key == cond)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete cond_wait_per_thread[tid, cond];
	}
	delete details_thread_count;
    }
}

probe
process(@PTHREAD_PATH).function(@_pthread_cond_destroy).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	cond = @ENTRY_ARG1;
	if (cond_init[cond] == -1)
	    possibly_double_destroy("pthread_cond_destroy",
				    "cond", cond);
	else
	    cond_init[cond] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlockattr_init).return
{
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr	= @ENTRY_ARG1;
	check_memory_reuse(attr, "rwlockattr");
	rwlockattr_init[attr] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlockattr_getpshared).return,
process(@PTHREAD_PATH).function(@_pthread_rwlockattr_setpshared).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
    }
    else
	report_error(ppfunc(), result);
}

/*
function
forget_rwlockattr(attr) {
}
 */

probe
process(@PTHREAD_PATH).function(@_pthread_rwlockattr_destroy).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr  = @ENTRY_ARG1;
	if (rwlockattr_init[attr] == -1)
	    possibly_double_destroy("pthread_rwlockattr_destroy",
				    "rwlockattr", attr);
	else
	    rwlockattr_init[attr] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_init).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	rwlock	= @ENTRY_ARG1;
	/*
	attr	= @ENTRY_ARG2;
	 */
	check_memory_reuse(rwlock, "rwlock");
	rwlock_init[rwlock] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

function common_rdlock(rdlock, istry, tmout, result) {
    if (result == 0) {
	rdlocks[rdlock] = tid();
	now = gettimeofday_us();
	if (verbose) {
	    ++rdlock_count[rdlock];
	    diff = now - rdlock_entry[tid(), rdlock];
	    rdlock_contention_total_time[rdlock] += diff;
	    if (!rdlock_contention_min_time[rdlock] ||
		rdlock_contention_min_time[rdlock] > diff)
		rdlock_contention_min_time[rdlock] = diff;
	    if (rdlock_contention_max_time[rdlock] < diff)
		rdlock_contention_max_time[rdlock] = diff;
	    ++rdlock_contention_count[rdlock];
	    ++rdlock_contention_per_thread[tid(), rdlock];
	}
	rdlock_entry[tid(), rdlock] = now;
    }
    else {
	report = 1;
	if (istry && result == @EBUSY)
	    report = trap_on_expected_busy;
	else if (tmout && result == @ETIMEDOUT) {
	    ++rdlock_contention_fail_timed[rdlock];
	    report = trap_on_expected_timedout;
	}
	if (report)
	    report_error(ppfunc(), result);
	delete rdlock_entry[tid(), rdlock];
	if (tmout)
	    delete rdlock_entry_timer[tid(), rdlock];
    }
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_rdlock) {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    rdlock_entry[tid(), rwlock] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_rdlock).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    common_rdlock(rwlock, 0, 0, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_tryrdlock) {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    rdlock_entry[tid(), rwlock] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_tryrdlock).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    common_rdlock(rwlock, 1, 0, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_timedrdlock) {
	if (pid() != target())
	next;
    rwlock	= @ARG1;
    tmout	= @ARG2;
    rdlock_entry[tid(), rwlock] = gettimeofday_us();
    rdlock_entry_timer[tid(), rwlock] = tmout;
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_timedrdlock).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    tmout	= @ENTRY_ARG2;
    common_rdlock(rwlock, 0, tmout, result);
}

function common_wrlock(wrlock, istry, tmout, result) {
    if (result == 0) {
	wrlocks[wrlock] = tid();
	now = gettimeofday_us();
	if (verbose) {
	    ++wrlock_count[wrlock];
	    diff = now - wrlock_entry[tid(), wrlock];
	    wrlock_contention_total_time[wrlock] += diff;
	    if (!wrlock_contention_min_time[wrlock] ||
		wrlock_contention_min_time[wrlock] > diff)
		wrlock_contention_min_time[wrlock] = diff;
	    if (wrlock_contention_max_time[wrlock] < diff)
		wrlock_contention_max_time[wrlock] = diff;
	    ++wrlock_contention_count[wrlock];
	    ++wrlock_contention_per_thread[tid(), wrlock];
	}
	wrlock_entry[tid(), wrlock] = now;
    }
    else {
	report = 1;
	if (istry && result == @EBUSY)
	    report = trap_on_expected_busy;
	else if (tmout && result == @ETIMEDOUT) {
	    ++wrlock_contention_fail_timed[wrlock];
	    report = trap_on_expected_timedout;
	}
	if (report)
	    report_error(ppfunc(), result);
	delete wrlock_entry[tid(), wrlock];
	if (tmout)
	    delete wrlock_entry_timer[tid(), wrlock];
    }
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_wrlock) {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    wrlock_entry[tid(), rwlock] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_wrlock).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    common_wrlock(rwlock, 0, 0, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_trywrlock) {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    wrlock_entry[tid(), rwlock] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_trywrlock).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    rwlock	= @ENTRY_ARG1;
    common_wrlock(rwlock, 1, 0, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_timedwrlock) {
    if (pid() != target())
	next;
    rwlock	= @ARG1;
    tmout	= @ARG2;
    wrlock_entry[tid(), rwlock] = gettimeofday_us();
    wrlock_entry_timer[tid(), rwlock] = tmout;
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_timedwrlock).return {
    if (pid() != target())
	next;
    result = @RETURN;
    rwlock	= @ENTRY_ARG1;
    tmout	= @ENTRY_ARG2;
    common_wrlock(rwlock, 0, tmout, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_unlock).return {
    if (pid() != target())
	next;
    result = @RETURN;
    rwlock = @ENTRY_ARG1;
    if (result)
	report_error(ppfunc(), result);
    else {
	rd = rdlocks[rwlock] == tid();
	if (!rd && wrlocks[rwlock] != tid()) {
	    possibly_double_unlock("pthread_rwlock_unlock", "rwlock",
				   tid(), rwlock);
	    next;
	}
	if (verbose) {
	    now = gettimeofday_us();
	    if (rd) {
		diff = now - rdlock_entry[tid(), rwlock];
		rdlock_total_time[rwlock] += diff;
		if (!rdlock_min_time[rwlock] ||
		    rdlock_min_time[rwlock] > diff)
		    rdlock_min_time[rwlock] = diff;
		if (rdlock_max_time[rwlock] < diff)
		    rdlock_max_time[rwlock] = diff;
	    }
	    else {
		diff = now - wrlock_entry[tid(), rwlock];
		wrlock_total_time[rwlock] += diff;
		if (!wrlock_min_time[rwlock] ||
		    wrlock_min_time[rwlock] > diff)
		    wrlock_min_time[rwlock] = diff;
		if (wrlock_max_time[rwlock] < diff)
		    wrlock_max_time[rwlock] = diff;
	    }
	}
    }
    if (rd) {
	delete rdlocks[rwlock];
	delete rdlock_entry[tid(), rwlock];
	delete rdlock_entry_timer[tid(), rwlock];
    }
    else {
	delete wrlocks[rwlock];
	delete wrlock_entry[tid(), rwlock];
	delete wrlock_entry_timer[tid(), rwlock];
    }
}

function
forget_rwlock(rwlock)
{
    delete rdlocks[rwlock];
    delete wrlocks[rwlock];
    if (verbose) {
	delete rdlock_count[rwlock];
	delete wrlock_count[rwlock];
	delete rdlock_contention_total_time[rwlock];
	delete wrlock_contention_total_time[rwlock];
	delete rdlock_contention_min_time[rwlock];
	delete wrlock_contention_min_time[rwlock];
	delete rdlock_contention_max_time[rwlock];
	delete wrlock_contention_max_time[rwlock];
	delete wrlock_contention_fail_try[rwlock];
	delete wrlock_contention_fail_timed[rwlock];
	delete rdlock_total_time[rwlock];
	delete wrlock_total_time[rwlock];
	delete rdlock_min_time[rwlock];
	delete wrlock_min_time[rwlock];
	delete rdlock_max_time[rwlock];
	delete wrlock_max_time[rwlock];
	foreach ([tid, key] in rdlock_contention_per_thread) {
	    if (key == rwlock)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete rdlock_contention_per_thread[tid, rwlock];
	}
	delete details_thread_count;
	foreach ([tid, key] in wrlock_contention_per_thread) {
	    if (key == rwlock)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete wrlock_contention_per_thread[tid, rwlock];
	}
	delete details_thread_count;
    }
    /* Should never happen or an error already triggered */
    if (expensive_checks) {
	destroyed = rwlock_init[rwlock] == -1;
	foreach ([tid, key] in rdlock_entry) {
	    if (key == rwlock)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("rdlock_entry", tid, rwlock, destroyed);
	    delete rdlock_entry[tid, rwlock];
	}
	delete details_thread_count;
	foreach ([tid, key] in rdlock_entry_timer) {
	    if (key == rwlock)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("rdlock_entry_timer", tid, rwlock, destroyed);
	    delete rdlock_entry_timer[tid, rwlock];
	}
	delete details_thread_count;
	foreach ([tid, key] in wrlock_entry) {
	    if (key == rwlock)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("wrlock_entry", tid, rwlock, destroyed);
	    delete wrlock_entry[tid, rwlock];
	}
	delete details_thread_count;
	foreach ([tid, key] in wrlock_entry_timer) {
	    if (key == rwlock)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("wrlock_entry_timer", tid, rwlock, destroyed);
	    delete wrlock_entry_timer[tid, rwlock];
	}
	delete details_thread_count;
    }
}

probe
process(@PTHREAD_PATH).function(@_pthread_rwlock_destroy).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	rwlock	= @ENTRY_ARG1;
	if (rwlock_init[rwlock] == -1)
	    possibly_double_destroy("pthread_rwlock_destroy",
				    "rwlock", rwlock);
	else
	    rwlock_init[rwlock] = -1;
    }
    else
	report_error(ppfunc(), result);
}

/* Does not resolve pthread_spin_init probe */
%(@GLIBC != "2.34" %?
probe
process(@PTHREAD_PATH).function(@_pthread_spin_init).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	spin	= @ENTRY_ARG1;
	/*
	shared	= @ENTRY_ARG2;
	 */
	check_memory_reuse(spin, "spin");
	spin_init[spin] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}
%: %)

function
common_spin_lock(spin, istry, result) {
    if (result == 0) {
	spinlocks[spin] = tid();
	now = gettimeofday_us();
	if (verbose) {
	    ++spin_count[spin];
	    diff = now - spin_entry[tid(), spin];
	    spin_contention_total_time[spin] += diff;
	    if (!spin_contention_min_time[spin] ||
		spin_contention_min_time[spin] > diff)
		spin_contention_min_time[spin] = diff;
	    if (spin_contention_max_time[spin] < diff)
		spin_contention_max_time[spin] = diff;
	    ++spin_contention_count[spin];
	    ++spin_contention_per_thread[tid(), spin];
	}
	spin_entry[tid(), spin] = now;
    }
    else {
	report = 1;
	if (istry) {
	    report = !trap_on_expected_busy || result != @EBUSY;
	    ++spin_contention_fail_try[spin];
	}
	if (report)
	    report_error(ppfunc(), result);
	delete spin_entry[tid(), spin];
    }
}

probe
process(@PTHREAD_PATH).function(@_pthread_spin_lock) {
    if (pid() != target())
	next;
    spin	= @ARG1;
    spin_entry[tid(), spin] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_spin_lock).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    spin	= @ENTRY_ARG1;
    common_spin_lock(spin, 0, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_spin_trylock) {
    if (pid() != target())
	next;
    spin	= @ARG1;
    spin_entry[tid(), spin] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_spin_trylock).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    spin	= @ENTRY_ARG1;
    common_spin_lock(spin, 1, result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_spin_unlock).return {
    if (pid() != target())
	next;
    result = @RETURN;
    spin = @ENTRY_ARG1;
    if (result)
	report_error(ppfunc(), result);
    else {
	if (!spin_entry[tid(), spin] || spinlocks[spin] != tid()) {
	    possibly_double_unlock("pthread_spin_unlock", "spin",
				   tid(), spin);
	    next;
	}
	if (verbose) {
	    --spin_count[spin];
	    now = gettimeofday_us();
	    diff = now - spin_entry[tid(), spin];
	    spin_total_time[spin] += diff;
	    if (!spin_min_time[spin] ||	spin_min_time[spin] > diff)
		spin_min_time[spin] = diff;
	    if (spin_max_time[spin] < diff)
		spin_max_time[spin] = diff;
	}
    }
    delete spinlocks[spin];
    delete spin_entry[tid(), spin];
}

function
forget_spinlock(spin) {
    delete spinlocks[spin];
    if (expensive_checks) {
	destroyed = spin_init[spin] == -1;
	foreach ([tid, key] in spin_entry) {
	    if (key == spin)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("spin_entry", tid, spin, destroyed);
	    delete spin_entry[tid, spin];
	}
	delete details_thread_count;
    }
    delete spin_count[spin];
    if (verbose) {
	delete spin_contention_total_time[spin];
	delete spin_contention_min_time[spin];
	delete spin_contention_max_time[spin];
	delete spin_contention_count[spin];
	delete spin_contention_fail_try[spin];
	foreach ([tid, key] in spin_contention_per_thread) {
	    if (key == spin)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete spin_contention_per_thread[tid, spin];
	}
	delete details_thread_count;
	delete spin_total_time[spin];
	delete spin_min_time[spin];
	delete spin_max_time[spin];
    }
}

/* Does not resolve pthread_spin_init probe, so skip pthread_spin_destroy */
%(@GLIBC != "2.34" %?
probe
process(@PTHREAD_PATH).function(@_pthread_spin_destroy).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	spin	= @ENTRY_ARG1;
	if (spin_init[spin] == -1)
	    possibly_double_destroy("pthread_spin_destroy",
				    "spin", spin);
	else
	    spin_init[spin] = -1;
    }
    else
	report_error(ppfunc(), result);
}
%: %)

probe
process(@PTHREAD_PATH).function(@_pthread_barrierattr_init).return
{
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr	= @ENTRY_ARG1;
	check_memory_reuse(attr, "barrierattr");
	barrierattr_init[attr] = gettimeofday_us();
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_barrierattr_getpshared).return,
process(@PTHREAD_PATH).function(@_pthread_barrierattr_setpshared).return
{
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
    }
    else
	report_error(ppfunc(), result);
}

/*
function
forget_barrierattr(attr) {
}
 */

probe
process(@PTHREAD_PATH).function(@_pthread_barrierattr_destroy).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    if (result == 0) {
	attr  = @ENTRY_ARG1;
	if (barrierattr_init[attr] == -1)
	    possibly_double_destroy("pthread_barrierattr_destroy",
				    "barrierattr", attr);
	else
	    barrierattr_init[attr] = -1;
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_barrier_init).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	barrier	= @ENTRY_ARG1;
	//attr	= @ENTRY_ARG2;
	count	= @ENTRY_ARG3;
	check_memory_reuse(barrier, "barrier");
	barrier_init[barrier] = tid();
	barrier_count[barrier] = count;
    }
    else
	report_error(ppfunc(), result);
}

probe
process(@PTHREAD_PATH).function(@_pthread_barrier_wait) {
    if (pid() != target())
	next;
    barrier	= @ARG1;
    barrier_entry[tid(), barrier] = gettimeofday_us();
}

probe
process(@PTHREAD_PATH).function(@_pthread_barrier_wait).return {
    if (pid() != target())
	next;
    result	= @RETURN;
    barrier	= @ARG1;
    if (result == 0 || result == @PTHREAD_BARRIER_SERIAL_THREAD) {
	barriers[barrier] = tid();
	now = gettimeofday_us();
	if (verbose) {
	    ++barrier_count[barrier];
	    diff = now - barrier_entry[tid(), barrier];
	    barrier_contention_total_time[barrier] += diff;
	    if (!barrier_contention_min_time[barrier] ||
		barrier_contention_min_time[barrier] > diff)
		barrier_contention_min_time[barrier] = diff;
	    if (barrier_contention_max_time[barrier] < diff)
		barrier_contention_max_time[barrier] = diff;
	    ++barrier_contention_count[barrier];
	    ++barrier_contention_per_thread[tid(),  barrier];
	}
	barrier_entry[tid(), barrier] = now;
    }
    else {
	report_error(ppfunc(), result);
	delete barrier_entry[tid(), barrier];
    }
}

function
forget_barrier(barrier) {
    delete barriers[barrier];
    if (expensive_checks) {
	destroyed = barrier_init[barrier] == -1;
	foreach ([tid, key] in barrier_entry) {
	    if (key == barrier)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    unexpected_condition("barrier_entry", tid, barrier, destroyed);
	    delete barrier_entry[tid, barrier];
	}
	delete details_thread_count;
    }
    delete barrier_count[barrier];
    if (verbose) {
	delete barrier_contention_total_time[barrier];
	delete barrier_contention_min_time[barrier];
	delete barrier_contention_max_time[barrier];
	delete barrier_contention_count[barrier];
	foreach ([tid, key] in barrier_contention_per_thread) {
	    if (key ==  barrier)
		details_thread_count[tid] = 1;
	}
	foreach (tid in details_thread_count) {
	    delete barrier_contention_per_thread[tid, barrier];
	}
	delete details_thread_count;
    }
}

probe
process(@PTHREAD_PATH).function(@_pthread_barrier_destroy).return {
    if (pid() != target())
	next;
    result = @RETURN;
    if (result == 0) {
	barrier	= @ENTRY_ARG1;
	if (barrier_init[barrier] == -1)
	    possibly_double_destroy("pthread_barrier_destroy",
				    "barrier", barrier);
	else
	    barrier_init[barrier] = -1;
    }
    else
	report_error(ppfunc(), result);
}

function
check_memory_reuse(pointer, type) {
    if (thread_to_tid[pointer]) {
	tid = thread_to_tid[pointer];
	if (expensive_checks && !uncertain_tids[tid]) {
	    if (exited_tids[tid])
		printf("exited ");
	    else if (joined_tids[tid])
		printf("joined ");
	    else if (canceled_tids[tid])
		printf("canceled ");
	    printf("tid %ld thread %p reused", tid, pointer);
	    if (type != "thread")
		printf(" as a %s", type);
	    printf("\n");
	}
	forget_tid(thread_to_tid[pointer], 1);
    }
    if (attr_init[pointer]) {
	if (expensive_checks && attr_init[pointer] != -1) {
	    printf("attr %p reused", pointer);
	    if (type != "attr")
		printf(" as a %s", type);
	    printf("\n");
	}
	// forget_attr(pointer);
    }
    if (mutexattr_init[pointer]) {
	if (expensive_checks && mutexattr_init[pointer] != -1) {
	    printf("mutexattr %p reused", pointer);
	    if (type != "mutexattr")
		printf(" as a %s", type);
	    printf("\n");
	}
	// forget_mutexattr(pointer);
    }
    else if (mutex_init[pointer]) {
	if (expensive_checks && mutex_init[pointer] != -1) {
	    printf("mutex %p reused", pointer);
	    if (type != "mutex")
		printf(" as a %s", type);
	    printf("\n");
	}
	forget_mutex(pointer);
    }
    else if (condattr_init[pointer]) {
	if (expensive_checks && condattr_init[pointer] != -1) {
	    printf("condattr %p reused", pointer);
	    if (type != "condattr")
		printf(" as a %s", type);
	    printf("\n");
	}
	// forget_condattr(pointer);
    }
    else if (cond_init[pointer]) {
	if (expensive_checks && cond_init[pointer] != -1) {
	    printf("cond %p reused", pointer);
	    if (type != "cond")
		printf(" as a %s", type);
	    printf("\n");
	}
	forget_condition(pointer);
    }
    else if (rwlockattr_init[pointer]) {
	if (expensive_checks && rwlockattr_init[pointer] != -1) {
	    printf("rwlockattr %p reused", pointer);
	    if (type != "rwlockattr")
		printf(" as a %s", type);
	    printf("\n");
	}
	// forget_rwlockattr(pointer);
    }
    else if (rwlock_init[pointer]) {
	if (expensive_checks && rwlock_init[pointer] != -1) {
	    printf("rwlock %p reused", pointer);
	    if (type != "rwlock")
		printf(" as a %s", type);
	    printf("\n");
	}
	forget_rwlock(pointer);
    }
    else if (spin_init[pointer]) {
	if (expensive_checks && spin_init[pointer] != -1) {
	    printf("spin %p reused", pointer);
	    if (type != "rwlock")
		printf(" as a %s", type);
	    printf("\n");
	}
	forget_spinlock(pointer);
    }
    else if (barrierattr_init[pointer]) {
	if (expensive_checks && barrierattr_init[pointer] != -1) {
	    printf("barrierattr %p reused", pointer);
	    if (type != "barrierattr")
		printf(" as a %s", type);
	    printf("\n");
	}
	// forget_barrierattr(pointer);
    }
    else if (barrier_init[pointer]) {
	if (expensive_checks && barrier_init[pointer] != -1) {
	    printf("barrier %p reused", pointer);
	    if (type != "barrier")
		printf(" as a %s", type);
	    printf("\n");
	}
	forget_barrier(pointer);
    }
}

function plural(count) {
    return count != 1 ? "s" : "";
}

function comma(count) {
    return count ? ", ": "";
}

function and(count) {
    return count ? " and ": "";
}

function time_string(usec:long) {
    result = "";
    msec = sec = min = hour = day = 0;
    temp = usec % 1000000;
    if (temp != usec) {
	msec = usec / 1000;
	usec = temp;
	if (msec) {
	    sec = msec / 1000;
	    if (sec) {
		msec %= 1000;
		min = sec / 60;
		if (min) {
		    sec %= 60;
		    hour = min / 60;
		    if (hour) {
			min %= 60;
			day = hour / 24;
			if (day)
			    hour %= 24;
		    }
		}
	    }
	}
    }
    if (day)
	result .= sprintf("%ld day%s", day, plural(day));
    if (hour)
	result .= sprintf("%s%ld hour%s",
			  comma(day), hour, plural(hour));
    if (min)
	result .= sprintf("%s%ld min%s",
			  comma(hour || day), min, plural(min));
    if (sec)
	result .= sprintf("%s%ld sec%s",
			  comma(min || hour || day),
			  sec, plural(sec));
    if (msec)
	result .= sprintf("%s%ld msec%s",
			  comma(sec || min || hour || day),
			  msec, plural(msec));
    if (usec)
	result .= sprintf("%s%ld usec%s",
			  and(msec || sec || min || hour || day),
			  usec, plural(usec));
    return result;
}

function report_mutex(now) {
    if (verbose) {
	count = 0;
	foreach ([tid, mutex] in mutex_contention_per_thread) {
	    ++details_thread_count[mutex];
	}
	foreach (mutex in mutex_contention_total_time) {
	    details[mutex, mutex_contention_total_time[mutex]] =
		details_thread_count[mutex];
	}
	delete details_thread_count;
	foreach ([mutex, time-] in details) {
	    if (mutex_contention_count[mutex]) {
		if (count++ >= report_mutex_count)
		    break;
		if (mutex_init[mutex])
		    printf("%s ",
			   mutex_init[mutex] > 0 ?
			   "initialized" : "*destroyed");
		if (mutex_consistent[mutex])
		    printf("%sconsistent ",
			   mutex_consistent[mutex] < 0 ? "*in" : "");
		if (mutex_prioceiling[mutex])
		    printf("%ld prioceiling ", mutex_prioceiling[mutex]);
		printf("mutex %p locked %ld time%s by %ld thread%s",
		       mutex,
		       mutex_contention_count[mutex],
		       plural(mutex_contention_count[mutex]),
		       details[mutex, time],
		       plural(details[mutex, time]));
		if (mutex_contention_fail_try[mutex])
		    printf(", %ld failed lock%s",
			   mutex_contention_fail_try[mutex],
			   plural(mutex_contention_fail_try[mutex]));
		if (mutex_contention_fail_timed[mutex])
		    printf(", %ld timedout lock%s",
			   mutex_contention_fail_timed[mutex],
			   plural(mutex_contention_fail_timed[mutex]));
		printf("\n");
		printf("    total contention	: %s\n", time_string(time));
		printf("    min contention	: %s\n",
		       time_string(mutex_contention_min_time[mutex]));
		printf("    max contention	: %s\n",
		       time_string(mutex_contention_max_time[mutex]));
		printf("    average contention	: %s\n",
		       time_string(mutex_contention_total_time[mutex] /
				   mutex_contention_count[mutex]));
		printf("    total lock		: %s\n",
		       time_string(mutex_lock_total_time[mutex]));
		printf("    min lock		: %s\n",
		       time_string(mutex_lock_min_time[mutex]));
		printf("    max lock		: %s\n",
		       time_string(mutex_lock_max_time[mutex]));
		printf("    average lock	: %s\n",
		       time_string(mutex_lock_total_time[mutex] /
				   mutex_contention_count[mutex]));
	    }
	}
	delete details;
    }
    foreach (mutex in mutex_lock) {
	tid = mutex_lock[mutex];
	if (tid)
	    details[mutex, now - mutex_lock_entry[tid, mutex]] = tid;
    }
    /* Order by time locked */
    foreach ([mutex, time-] in details) {
	if (mutex_init[mutex])
	    printf("%s ",
		   mutex_init[mutex] > 0 ? "initialized" : "*destroyed");
	if (mutex_consistent[mutex])
	    printf("%sconsistent ", mutex_consistent[mutex] < 0 ? "*in" : "");
	if (mutex_prioceiling[mutex])
	    printf("%ld prioceiling ", mutex_prioceiling[mutex]);
	locker = mutex_lock[mutex];
	printf("mutex %p locked for %s by tid %ld\n",
	       mutex, time_string(time), locker);
	foreach ([tid, key] in mutex_lock_entry) {
	    if (key == mutex && tid != locker && mutex_lock_entry[tid, key])
		printf("    tid %ld waiting for %s\n", tid,
		       time_string(now - mutex_lock_entry[tid, key]));
	}
    }
    delete details;
}

function report_cond(now) {
    if (verbose) {
	count = 0;
	foreach ([tid, cond] in cond_wait_per_thread) {
	    ++details_thread_count[cond];
	}
	foreach ([tid, cond] in cond_signal_per_thread) {
	    ++details_signal_count[cond];
	}
	foreach ([tid, cond] in cond_broadcast_per_thread) {
	    ++details_broadcast_count[cond];
	}
	foreach (cond in cond_wait_total_time) {
	    details[cond, cond_wait_total_time[cond]] =
		details_thread_count[cond];
	}
	delete details_thread_count;
	foreach ([cond, time-] in details) {
	    if (count++ >= report_cond_count)
		break;
	    printf("%s ",
		   cond_init[cond] > 0 ? "initialized" : "*destroyed");
	    printf("condition %p waited %ld time%s by %ld thread%s",
		   cond,
		   cond_wait_count[cond],
		   plural(cond_wait_count[cond]),
		   details[cond, time],
		   plural(details[cond, time]));
		if (cond_wait_timedout[cond])
		    printf(", %ld timedout waits",
			   cond_wait_timedout[cond]);
	    if (cond_signal_count[cond])
		printf(", signaled %ld time%s by %ld thread%s",
		       cond_signal_count[cond],
		       plural(cond_signal_count[cond]),
		       details_signal_count[cond],
		       plural(details_signal_count[cond]));
	    if (cond_broadcast_count[cond])
		printf(", broadcast %ld time%s by %ld thread%s",
		       cond_broadcast_count[cond],
		       plural(cond_broadcast_count[cond]),
		       details_broadcast_count[cond],
		       plural(details_broadcast_count[cond]));
		printf("\n");
		printf("    total wait	: %s\n", time_string(time));
		printf("    min wait	: %s\n",
		       time_string(cond_wait_min_time[cond]));
		printf("    max wait	: %s\n",
		       time_string(cond_wait_max_time[cond]));
		printf("    average wait: %s\n",
		       time_string(cond_wait_total_time[cond] /
				   cond_wait_count[cond]));
	}
	delete details_broadcast_count;
	delete details_signal_count;
	delete details;
    }
    foreach ([tid, cond] in cond_wait) {
	if (cond_wait[tid, cond]) {
	    conditions[cond] = 1;
	    details[cond, now - cond_wait[tid, cond]] = tid;
	}
    }
    foreach (condition in conditions) {
	printf("%s ",
	       cond_init[condition] > 0 ? "initialized" : "*destroyed");
	printf("condition %p\n", condition);
	foreach ([cond, time-] in details) {
	    if (cond == condition) {
		tid = details[cond, time];
		mutex = mutex_wait[tid, cond];
		printf("    mutex %p waiting for %s by tid %ld\n",
		       mutex, time_string(time), tid);
	    }
	}
    }
    delete details;
    delete conditions;
}

function report_rdlock(now) {
    if (verbose) {
	count = 0;
	foreach ([tid, rdlock] in rdlock_contention_per_thread) {
	    ++details_thread_count[rdlock];
	}
	foreach (rdlock in rdlock_contention_total_time) {
	    details[rdlock, rdlock_contention_total_time[rdlock]] =
		details_thread_count[rdlock];
	}
	delete details_thread_count;
	foreach ([rdlock, time-] in details) {
	    if (rdlock_contention_count[rdlock]) {
		if (count++ >= report_rdlock_count)
		    break;
		if (rwlock_init[rdlock])
		    printf("%s ",
			   rwlock_init[rdlock] > 0 ?
			   "initialized" : "*destroyed");
		printf("rdlock %p locked %ld time%s by %ld thread%s",
		       rdlock,
		       rdlock_contention_count[rdlock],
		       plural(rdlock_contention_count[rdlock]),
		       details[rdlock, time],
		       plural(details[rdlock, time]));
		if (rdlock_contention_fail_try[rdlock])
		    printf(", %ld failed lock%s",
			   rdlock_contention_fail_try[rdlock],
			   plural(rdlock_contention_fail_try[rdlock]));
		if (rdlock_contention_fail_timed[rdlock])
		    printf(", %ld timedout lock%s",
			   rdlock_contention_fail_timed[rdlock],
			   plural(rdlock_contention_fail_timed[rdlock]));
		printf("\n");
		printf("    total contention	: %s\n", time_string(time));
		printf("    min contention	: %s\n",
		       time_string(rdlock_contention_min_time[rdlock]));
		printf("    max contention	: %s\n",
		       time_string(rdlock_contention_max_time[rdlock]));
		printf("    average contention	: %s\n",
		       time_string(rdlock_contention_total_time[rdlock] /
				   rdlock_contention_count[rdlock]));
		printf("    total lock		: %s\n",
		       time_string(rdlock_total_time[rdlock]));
		printf("    min lock		: %s\n",
		       time_string(rdlock_min_time[rdlock]));
		printf("    max lock		: %s\n",
		       time_string(rdlock_max_time[rdlock]));
		printf("    average lock	: %s\n",
		       time_string(rdlock_total_time[rdlock] /
				   rdlock_contention_count[rdlock]));
	    }
	}
	delete details;
    }
    foreach (rdlock in rdlocks) {
	tid = rdlocks[rdlock];
	if (tid)
	    details[rdlock, now - rdlock_entry[tid, rdlock]] = tid;
    }
    foreach ([rdlock, time-] in details) {
	if (rwlock_init[rdlock])
	    printf("%s ",
		   rwlock_init[rdlock] > 0 ? "initialized" : "*destroyed");
	locker = rdlocks[rdlock];
	printf("rwlock read lock %p by %ld\n", rdlock, locker);
	foreach ([tid, key] in rdlock_entry) {
	    if (key == rdlock && tid != locker && rdlock_entry[tid, key])
		printf("    tid %ld waiting for %s\n", tid,
		       time_string(now - rdlock_entry[tid, key]));
	}
    }
    delete details;
}

function report_wrlock(now) {
    if (verbose) {
	count = 0;
	foreach ([tid, wrlock] in wrlock_contention_per_thread) {
	    ++details_thread_count[wrlock];
	}
	foreach (wrlock in wrlock_contention_total_time) {
	    details[wrlock, wrlock_contention_total_time[wrlock]] =
		details_thread_count[wrlock];
	}
	delete details_thread_count;
	foreach ([wrlock, time-] in details) {
	    if (wrlock_contention_count[wrlock]) {
		if (count++ >= report_wrlock_count)
		    break;
		if (rwlock_init[wrlock])
		    printf("%s ",
			   rwlock_init[wrlock] > 0 ?
			   "initialized" : "*destroyed");
		printf("wrlock %p locked %ld time%s by %ld thread%s",
		       wrlock,
		       wrlock_contention_count[wrlock],
		       plural(wrlock_contention_count[wrlock]),
		       details[wrlock, time],
		       plural(details[wrlock, time]));
		if (wrlock_contention_fail_try[wrlock])
		    printf(", %ld failed lock%s",
			   wrlock_contention_fail_try[wrlock],
			   plural(wrlock_contention_fail_try[wrlock]));
		if (wrlock_contention_fail_timed[wrlock])
		    printf(", %ld timedout lock%s",
			   wrlock_contention_fail_timed[wrlock],
			   plural(wrlock_contention_fail_timed[wrlock]));
		printf("\n");
		printf("    total contention	: %s\n", time_string(time));
		printf("    min contention	: %s\n",
		       time_string(wrlock_contention_min_time[wrlock]));
		printf("    max contention	: %s\n",
		       time_string(wrlock_contention_max_time[wrlock]));
		printf("    average contention	: %s\n",
		       time_string(wrlock_contention_total_time[wrlock] /
				   wrlock_contention_count[wrlock]));
		printf("    total lock		: %s\n",
		       time_string(wrlock_total_time[wrlock]));
		printf("    min lock		: %s\n",
		       time_string(wrlock_min_time[wrlock]));
		printf("    max lock		: %s\n",
		       time_string(wrlock_max_time[wrlock]));
		printf("    average lock	: %s\n",
		       time_string(wrlock_total_time[wrlock] /
				   wrlock_contention_count[wrlock]));
	    }
	}
	delete details;
    }
    foreach (wrlock in wrlocks) {
	tid = wrlocks[wrlock];
	if (tid)
	    details[wrlock, now - wrlock_entry[tid, wrlock]] = tid;
    }
    foreach ([wrlock, time-] in details) {
	if (rwlock_init[wrlock])
	    printf("%s ",
		   rwlock_init[wrlock] > 0 ? "initialized" : "*destroyed");
	locker = wrlocks[wrlock];
	printf("rwlock write lock %p by %ld\n", wrlock, locker);
	foreach ([tid, key] in wrlock_entry) {
	    if (key == wrlock && tid != locker && wrlock_entry[tid, key])
		printf("    tid %ld waiting for %s\n", tid,
		       time_string(now - wrlock_entry[tid, key]));
	}
    }
    delete details;
}

function report_spin(now) {
        if (verbose) {
	count = 0;
	foreach ([tid, spin] in spin_contention_per_thread) {
	    ++details_thread_count[spin];
	}
	foreach (spin in spin_contention_total_time) {
	    details[spin, spin_contention_total_time[spin]] =
		details_thread_count[spin];
	}
	delete details_thread_count;
	foreach ([spin, time-] in details) {
	    if (spin_contention_count[spin]) {
		if (count++ >= report_spin_count)
		    break;
		if (spin_init[spin])
		    printf("%s ",
			   spin_init[spin] > 0 ?
			   "initialized" : "*destroyed");
		printf("spin %p locked %ld time%s by %ld thread%s",
		       spin,
		       spin_contention_count[spin],
		       plural(spin_contention_count[spin]),
		       details[spin, time],
		       plural(details[spin, time]));
		if (spin_contention_fail_try[spin])
		    printf(", %ld failed lock%s",
			   spin_contention_fail_try[spin],
			   plural(spin_contention_fail_try[spin]));
		printf("\n");
		printf("    total contention	: %s\n", time_string(time));
		printf("    min contention	: %s\n",
		       time_string(spin_contention_min_time[spin]));
		printf("    max contention	: %s\n",
		       time_string(spin_contention_max_time[spin]));
		printf("    average contention	: %s\n",
		       time_string(spin_contention_total_time[spin] /
				   spin_contention_count[spin]));
		printf("    total lock		: %s\n",
		       time_string(spin_total_time[spin]));
		printf("    min lock		: %s\n",
		       time_string(spin_min_time[spin]));
		printf("    max lock		: %s\n",
		       time_string(spin_max_time[spin]));
		printf("    average lock	: %s\n",
		       time_string(spin_total_time[spin] /
				   spin_contention_count[spin]));
	    }
	}
	delete details;
    }
    foreach (spin in spinlocks) {
	tid = spinlocks[spin];
	if (tid)
	    details[spin, now - spin_entry[tid, spin]] = tid;
    }
    foreach ([spin, time-] in details) {
	if (spin_init[spin])
	    printf("%s ",
		   spin_init[spin] > 0 ? "initialized" : "*destroyed");
	locker = spinlocks[spin];
	printf("spinlock %p by %ld\n", spin, locker);
	foreach ([tid, key] in spin_entry) {
	    if (key == spin && tid != locker && spin_entry[tid, key])
		printf("    tid %ld waiting for %s\n", tid,
		       time_string(now - spin_entry[tid, key]));
	}
    }
    delete details;
}

function report_barrier(now) {
    if (verbose) {
	count = 0;
	foreach ([tid, barrier] in barrier_contention_per_thread) {
	    ++details_thread_count[barrier];
	}
	foreach (barrier in barrier_contention_total_time) {
	    details[barrier, barrier_contention_total_time[barrier]] =
		details_thread_count[barrier];
	}
	delete details_thread_count;
	foreach ([barrier, time-] in details) {
	    if (barrier_contention_count[barrier]) {
		if (count++ >= report_barrier_count)
		    break;
		if (barrier_init[barrier])
		    printf("%s ",
			   barrier_init[barrier] > 0 ?
			   "initialized" : "*destroyed");
		printf("barrier %p blocked %ld time%s by %ld thread%s\n",
		       barrier,
		       barrier_contention_count[barrier],
		       plural(barrier_contention_count[barrier]),
		       details[barrier, time],
		       plural(details[barrier, time]));
		printf("    total contention	: %s\n", time_string(time));
		printf("    min contention	: %s\n",
		       time_string(barrier_contention_min_time[barrier]));
		printf("    max contention	: %s\n",
		       time_string(barrier_contention_max_time[barrier]));
		printf("    average contention	: %s\n",
		       time_string(barrier_contention_total_time[barrier] /
				   barrier_contention_count[barrier]));
	    }
	}
	delete details;
    }
    foreach (barrier in barriers) {
	tid = barriers[barrier];
	if (tid)
	    details[barrier, now - barrier_entry[tid, barrier]] = tid;
    }
    foreach ([barrier, time-] in details) {
	destroyed = barrier_init[barrier] == -1;
	printf("%s ", destroyed ?  "*destroyed" : "initialized");
	printf("barrier %p", barrier);
	if (!destroyed)
	    printf(" by %ld\n", barrier_init[barrier]);
	printf("\n");
	foreach ([tid, key] in barrier_entry) {
	    if (key == barrier && barrier_entry[tid, key])
		printf("    tid %ld waiting for %s\n", tid,
		       time_string(now - barrier_entry[tid, key]));
	}
    }
    delete details;
}

function report() {
    printf("\nReport for %s (%s)\n", process_name, process_arguments);
    if (verbose) {
	printf("tid to pthread\n");
	foreach (tid in tid_to_thread) {
	    thread = tid_to_thread[tid];
	    printf("    %ld %p %s\n", tid, thread, thread_name[thread]);
	}
    }
    now = gettimeofday_us();
    report_mutex(now);
    report_cond(now);
    report_rdlock(now);
    report_wrlock(now);
    report_spin(now);
    report_barrier(now);
}

probe signal.send {
    if (sig_name == "SIGURG" && sig_pid == target())
	report();
}

probe kprocess.exec {
    if (pid() != target())
	next;
    process_path = filename;
    exec_process_arguments = argstr;
}

probe kprocess.exec_complete {
    if (pid() != target())
	next;
    if (success) {
	if (process_name != "") {
	    report();
	    reset();
	}

	if (start_gdbserver) {
	    printf("binary_path_for_gdbserver = %s\nprocess_path = %s\n",
		   binary_path_for_gdbserver, process_path);
	}

	if (start_gdbserver &&
	    ((binary_path_for_gdbserver != "" &&
	      (binary_path_for_gdbserver == process_path ||
	       /* process_path is a string starting/ending with quotes */
	       sprintf("\"%s\"", binary_path_for_gdbserver) == process_path ||
	       /* Extra heuristic to match "/bin/foo" in "/usr/bin/foo"
		* and simplify the logic to "work as intended" */
	       isinstr(process_path, binary_path_for_gdbserver))) ||
	     (binary_path_for_gdbserver == "" && process_path != "")))
	    run_gdbserver(pid());
	process_name = execname();
	process_arguments = exec_process_arguments;
    }
}

function reset() {
    delete tid_to_thread;
    delete thread_to_tid;
    delete exited_tids;
    delete joined_tids;
    delete canceled_tids;
    delete uncertain_tids;
    delete attr_init;
    if (verbose) {
	delete thread_name;
	delete mutex_contention_total_time;
	delete mutex_contention_min_time;
	delete mutex_contention_max_time;
	delete mutex_contention_count;
	delete mutex_contention_per_thread;
	delete mutex_contention_fail_try;
	delete mutex_contention_fail_timed;
	delete mutex_lock_total_time;
	delete mutex_lock_min_time;
	delete mutex_lock_max_time;
	delete cond_wait_count;
	delete cond_wait_per_thread;
	delete cond_wait_total_time;
	delete cond_wait_min_time;
	delete cond_wait_max_time;
	delete cond_wait_timedout;
	delete cond_signal_count;
	delete cond_signal_per_thread;
	delete cond_broadcast_count;
	delete cond_broadcast_per_thread;
	delete rdlock_count;
	delete rdlock_contention_total_time;
	delete rdlock_contention_min_time;
	delete rdlock_contention_max_time;
	delete rdlock_contention_count;
	delete rdlock_contention_per_thread;
	delete rdlock_contention_fail_try;
	delete rdlock_contention_fail_timed;
	delete rdlock_total_time;
	delete rdlock_min_time;
	delete rdlock_max_time;
	delete wrlock_count;
	delete wrlock_contention_total_time;
	delete wrlock_contention_min_time;
	delete wrlock_contention_max_time;
	delete wrlock_contention_count;
	delete wrlock_contention_per_thread;
	delete wrlock_contention_fail_try;
	delete wrlock_contention_fail_timed;
	delete wrlock_total_time;
	delete wrlock_min_time;
	delete wrlock_max_time;
	delete spin_count;
	delete spin_contention_total_time;
	delete spin_contention_min_time;
	delete spin_contention_max_time;
	delete spin_contention_count;
	delete spin_contention_per_thread;
	delete spin_contention_fail_try;
	delete spin_total_time;
	delete spin_min_time;
	delete spin_max_time;
	delete barrier_count;
	delete barrier_contention_total_time;
	delete barrier_contention_min_time;
	delete barrier_contention_max_time;
	delete barrier_contention_count;
	delete barrier_contention_per_thread;
    }
    delete mutexattr_init;
    delete mutex_lock;
    delete mutex_lock_entry;
    delete mutex_lock_entry_timer;
    delete mutex_consistent;
    delete mutex_prioceiling;
    delete mutex_init;
    delete condattr_init;
    delete mutex_wait;
    delete cond_wait;
    delete cond_wait_timer;
    delete cond_init;
    delete rwlockattr_init;
    delete rwlock_init;
    delete rdlocks;
    delete rdlock_entry;
    delete rdlock_entry_timer;
    delete wrlocks;
    delete wrlock_entry;
    delete wrlock_entry_timer;
    delete spin_init;
    delete spin_entry;
    delete spinlocks;
    delete barrierattr_init;
    delete barrier_init;
    delete barrier_entry;
    delete barrier_count;
    delete barriers;
}

probe end {
    report();
    reset();
    printf("Stap done.\n");
}
