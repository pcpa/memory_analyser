#!/usr/bin/stap

/*
 - Simple memory usage diagnostics tool, requires glibc  and libstdc++
 - As long as systemtap works during execution, otherwise see:
   https://sourceware.org/systemtap/wiki/TipExhaustedResourceErrors
   it should only not list memory allocated with direct syscalls or
   get confused with munmap calls that release partial amounts of memory
 - Calls to mmap actually maping a file in memory might also end
   with inconsistent results

 - Once the program exits, or receives a SIGURG, a diagnostic is printed of
   all known memory allocations.
 - The script attempts to do its best to keep track of memory allocation and
   release to avoid printing misleading data, but it almost certainly has
   bugs.

 To match the code address, you might temporarily run:
 # echo 0 > /proc/sys/kernel/randomize_va_space
 or after a kill -URG attach gdb to the process and disassemble the address.
 Backtraces are not saved, otherwise the tool would be only useful for very
 small binaries.
 The tool/script attempts to have some use by saving the return address of
 the memory allocation routine.

 Works only on x86_64. Does not really need glibc nor libstdc++ debuginfo,
 as it takes values direct from registers, and due to this, needs to know
 about the abi.

 Should work at least on RHEL8, RHEL9 and Fedora 39.
 Likely to "bitrot" in a few years and/or Linux releases.

 Preparing to run:
 # dnf install -y systemtap
 # stap-prep

 Running the script:
 # stap -DMAXMAPENTRIES=262144 -DSTP_OVERLOAD_THRESHOLD=1073741824LL -DSTP_OVERLOAD_INTERVAL=2147483648LL -DMAXACTION=16384 memory.stp -c $COMMAND
 (( note the options, that otherwise, will fail for not so large binaries ))

 Forcing printing diagnostics:
 # kill -URG $(pidof $COMMAND)

 Checking the code:
 # gdb -p $(pidof $COMMAND)

 In gdb, can check addresses with something like:
 (gdb) x/20i $ADDRESS-32
 or
 (gdb) disassemble $ADDRESS

  Sample output with full verbose mode:

$ stap -DMAXMAPENTRIES=262144 -Gverbose=3 -DSTP_OVERLOAD_THRESHOLD=1073741824LL -DSTP_OVERLOAD_INTERVAL=2147483648LL -DMAXACTION=65536 -DMAXSTRINGLEN=4096 memory.stp -c /bin/ls
Stap ready.
memory.stp  README
Stap done.

            Size	      Count     	Allocator       	Code Address
------------------------------------------------------------------------------------------------
             166	      15-1       	malloc          	0x7f20867f260f (strdup) 0x555d562f62c0(12) 0x555d562f7240(12) 0x555d562f7260(12) 0x555d562f7280(12) 0x555d562f72a0(12) 0x555d562f72c0(12) 0x555d562f72e0(12) 0x555d562f7300(12) 0x555d562f7320(12) 0x555d562f7340(12) 0x555d562f7360(12) 0x555d562f7380(12) 0x555d562f73a0(12) 0x555d562f7410(10)
       224366320	       1-0       	mmap            	0x7f2086782752 (_nl_load_locale_from_archive) 0x7f2079000000(224366320)
             120	       1-0       	malloc          	0x7f20867824f4 (_nl_load_locale_from_archive) 0x555d562f62e0(120)
             792	       1-0       	malloc          	0x7f2086781950 (_nl_intern_locale_data) 0x555d562f6360(792)
            2864	      11-0       	malloc          	0x7f2086781863 (_nl_intern_locale_data) 0x555d562f6680(104) 0x555d562f66f0(1328) 0x555d562f6c30(208) 0x555d562f6d10(424) 0x555d562f6ec0(96) 0x555d562f6f30(80) 0x555d562f6f90(112) 0x555d562f7010(160) 0x555d562f70c0(96) 0x555d562f7130(72) 0x555d562f7180(184)
              12	       1-0       	malloc          	0x7f20867806ac (new_composite_name) 0x555d562f73c0(12)
              34	       1-0       	malloc          	0x7f2086784393 (set_binding_values.part.0) 0x555d562f73e0(34)
             112	       2-0       	malloc          	0x555d2d3869cc  -  0x555d562f7430(56) 0x555d562f7470(56)
             128	       1-0       	malloc          	0x555d2d37e65a (tzalloc) 0x555d562f74b0(128)
           20800	       1-0       	reallocarray    	0x555d2d37a3a7 (main) 0x555d562f7540(20800)
              18	       3-1       	malloc          	0x555d2d38653f (xstrdup) 0x555d56304720(7) 0x555d56304740(11)
              48	       1-0       	reallocarray    	0x555d2d383f21 (sort_files) 0x555d562fc6e0(48)
              96	       1-0       	reallocarray    	0x555d2d384c9c  -  0x555d562fc720(96)
              80	       1-0       	reallocarray    	0x555d2d384cf2  -  0x555d562fc790(80)
Bogus Total                                              224391590 (       0xd5ff1a6)
Bogus Break [0x555d562f6000  -  0x555d56317000] =           135168 (         0x21000)
Bogus Heap                                                   25270 (          0x62b6)
Bogus NoMap                                                  25270 (          0x62b6)

  Bogus Total is accounted memory not released
  Bogus Break is accounted memory in main arena
  Bogus Heap  is accounted memory in use and allocated from main arena
  Bogus NoMap is accounted memory not released but not allocated with m(re)map

  For single threaded applications, Bogus Heap and Bogus NoMap should have
  the same value on normal conditions (sans bugs or conditions not handled).
  For multithreaded applications usually Bogus NoMap will have a higher value,
  depending on memory not released by thread and/or if the application exits
  without joining all threads.

  Note that "not released" does not mean a detected leak. The memory usually
  should be reachable; this script does not attempt to check if pointers are
  reachable during report. The kernel eventually will release all memory when
  the application exits. Still, the closer to 0 is left as Bogus Heap and
  Bogus NoMap the closer to leak free the binary is.

  Note that the call to probefunc() is better than ppfunc() because probefunc()
  was the best I could get to some symbolic information in verbose mode.

 Author:	Paulo Cesar Pereira de Andrade
 */

global bytes_alloced_in_code_address;
global pointer_alloc_addresses_in_code;
global pointer_sizes;
global detailed_report;
global string_truncate_length;
global process_name = "";
global process_arguments, exec_process_arguments;

/* Bogus malloc main_arena area information */
global break_start;
global break_end;
global break_alloc = 0;

/* -Gverbose=1 to print allocator names */
global verbose = 0;

/* Unless there is a special need, these "watch points" should be direct
 * variables, instead of a list of values, what would require a hash table
 * lookup. These are only meaningful with address randomization disabled. */
/* -Gwatch_address=<address> to print user backtrace when allocating
 * from the given address */
global watch_address = 0;
/* -Gwatch_pointer=<pointer> to print user backtrace when an allocation
 * returns the given pointer.*/
global watch_pointer = 0;
/* -Gtrap_on_watch=1 to raise SIGTRAP if one of the pseudo watchpoints
 * is reached. This requires running systemtap in guru mode. */
global trap_on_watch = 0;
/* -Gshow_invalid=1 to print an backtrace if an invalid pointer is passed
 * to free/mremap/realloc. Note that this obviously should only be used
 * if not attaching to a running process, otherwise it might trap on
 * valid data. */
global show_invalid = -1;
/* -Gshow_non_portable=1 to print a backtrace if passing zero as size for
 * memory allocation. Glibc returns a valid pointer, but other libcs
 * can return NULL. */
global show_non_portable = 0;
/* -Gtrap_on_invalid=1 to raise SIGTRAP if an invalid pointer is passed
 * to free/mremap/realloc. Note that this obviously should only be used
 * if not attaching to a running process, otherwise it might trap on
 * valid data. */
global trap_on_invalid = 0;
/* -Gworkaround_glibc=0 to possibly show invalid/unknown pointer, in the
 * pattern:

Invalid/unknown pointer 0x7fffd0001150
 0x7fffed369360 : cfree@GLIBC_2.2.5+0x0/0x110 [/usr/lib64/libc.so.6]
 0x7fffed3694cb : __malloc_arena_thread_freeres+0x5b/0x150 [/usr/lib64/libc.so.6]
 0x7fffed35870f : start_thread+0x16f/0x480 [/usr/lib64/libc.so.6]
 0x7fffed3dfa5c : __GI___clone3+0x2c/0x50 [/usr/lib64/libc.so.6]

  This happens because __malloc_arena_thread_freeres() calls
  tcache_thread_shutdown(), that has:

    tcache_perthread_struct *tcache_tmp = tcache;
and after releasing all tcache entries with _libc_free() finally calls:
  __libc_free (tcache_tmp);

 The problem is that malloc/malloc.c has:
static __thread tcache_perthread_struct *tcache = NULL;
and tcache_init() calls _int_malloc(), not _libc_malloc() to initialize it.

  Another case is munmap call from a block directly allocated with a mmap
sycall, when creating a new arena. A warning would be printed for every
arena created.
 */
global workaround_glibc = 1;

/* Start pretending it did attach to running process. Changed in begin probe, */
global attached = 1;

/* avoid realloc return probe computed twice */
global realloc_null_is_malloc = 1;
/* avoid reallocarray and realloc return probes being computed */
global reallocarray_is_realloc = 1;

/* avoid double stats */
global news;
global deletes;

/* alloc type in verbose mode */
global allocs;

/* set while in a signal handler context */
global handling_signal;

/* Number of alloc hits in verbose mode */
global count_alloced_in_code_address;
/* Number of release hits in verbose mode */
global count_freed_in_code_address;
/* Approximate probe name in verbose name */
global code_probe_names;

/* constants (kind of) */
global n_mmap = 1;
global n_mremap = 2;
global n_malloc = 3;
global n_calloc = 4;
global n_realloc = 5;
global n_reallocarray = 6;
global n_posix_memalign = 7;
global n_aligned_alloc = 8;
global n_new = 9;

probe begin {
    pid = target();
    %( $# < 1 %? attached = 0 %: pid = $1 %);
    task = pid2task(pid);
    if (task == 0)
	error(sprintf("Process-id %d is invalid, please provide valid PID as $1 or -x PID", pid));
    if (!attached && trap_on_invalid)
	printf("-Gtrap_on_invalid might generate false positives when attaching to a pid.");
    if (show_invalid == -1)
	show_invalid = trap_on_invalid || !attached;
    printf("Stap ready.\n");
}

function handle_watch(handle_address, handle_pointer) {
    if (handle_address && handle_pointer)
	printf("\nWatch address %p - pointer %p:\n",
	       watch_address, watch_pointer);
    else if (handle_address)
	printf("\nWatch address %p:\n", watch_address);
    else if (handle_pointer)
	printf("\nWatch pointer %p:\n", watch_pointer);
    else
	return;
    print_ubacktrace();
    %(guru_mode != 0 %?
      if (trap_on_watch) raise(%{ SIGTRAP %}) %:
	  if (trap_on_watch) printf("trap_on_watch needs guru mode\n")
	  %);
}

function handle_invalid(pointer) {
    if (show_invalid) {
	if (workaround_glibc) {
	    /* The tcache per thread variable is free'd with a free call, but
	     * allocated with a short-circuit call to _int_malloc.
	     */
	    backtrace = sprint_ubacktrace();
	    if (backtrace !~ "__malloc_arena_thread_freeres+" ||
		(backtrace !~ "__munmap+" && backtrace !~ "alloc_new_heap+"))
		return;
	}
	printf("\nInvalid/unknown pointer %p\n", pointer);
	print_ubacktrace();
	%(guru_mode != 0 %?
	  if (trap_on_invalid) raise(%{ SIGTRAP %}) %:
	      if (trap_on_invalid) printf("trap_on_invalid needs guru mode\n")
		  %);
    }
}

function handle_non_portable(pointer) {
    if (show_non_portable) {
	printf("\nNon portable zero sized allocation %p\n", pointer);
	print_ubacktrace();
    }
}

function check_signal() {
    if (handling_signal) {
	printf("\nMemory allocation during %s signal handler\n",
	       signal_str(handling_signal));
	print_ubacktrace();
    }
}

probe
process("/lib64/libc.so.6").function("brk"),
process("/lib64/libc.so.6").function("sbrk"),
process("/lib64/libc.so.6").function("mmap"),
process("/lib64/libc.so.6").function("mremap"),
process("/lib64/libc.so.6").function("munmap"),
process("/lib64/libc.so.6").function("malloc"),
process("/lib64/libc.so.6").function("valloc"),
process("/lib64/libc.so.6").function("pvalloc"),
process("/lib64/libc.so.6").function("calloc"),
process("/lib64/libc.so.6").function("reallocarray"),
process("/lib64/libc.so.6").function("posix_memalign"),
process("/lib64/libc.so.6").function("aligned_alloc"),
process("/lib64/libc.so.6").function("memalign")
{
    if (pid() != target())
	next;
    check_signal();
}

probe process("/lib64/libc.so.6").function("brk").return {
    if (pid() != target())
	next;
    result = @defined($return) ? $return : register("rax");
    if (result == 0) {
	pointer = @defined(@entry($arg1)) ?
			   @entry($arg1) : @entry(register("rdi"));
	handle_watch(uaddr() == watch_address,
		     pointer && pointer == watch_pointer);
	if (break_start == 0 || pointer < break_start)
	    break_start = pointer;
	if (break_end == 0 || pointer > break_end)
	    break_end = pointer;
    }
}

probe process("/lib64/libc.so.6").function("sbrk").return {
    if (pid() != target())
	next;
    pointer = @defined($return) ? $return : register("rax");
    if (pointer != -1) {
	handle_watch(uaddr() == watch_address,
		     pointer && pointer == watch_pointer);
	/*
	increment = @defined(@entry($arg1)) ?
			     @entry($arg1) : @entry(register("rdi"));
	 */
	if (break_start == 0 || pointer < break_start)
	    break_start = pointer;
	if (break_end == 0 || pointer > break_end)
	    break_end = pointer;
    }
}

function forget(address:long) {
    /* Avoid remembering non useful information for too long */
    if (verbose)
	delete allocs[address];
}

probe process("/lib64/libc.so.6").function("mmap").return {
    if (pid() != target())
	next;
    pointer = @defined($return) ? $return : register("rax");
    if (pointer != -1) {
	code_address = uaddr();
	size = @defined(@entry($arg2)) ?
			@entry($arg2) : @entry(register("rsi"));
	handle_watch(code_address == watch_address,
		     pointer && pointer == watch_pointer);
	bytes_alloced_in_code_address[code_address] += size;
	pointer_alloc_addresses_in_code[pointer] = code_address;
	pointer_sizes[pointer] = size;
	if (verbose) {
	    allocs[code_address] = n_mmap;
	    ++count_alloced_in_code_address[code_address];
	    if (verbose > 1)
		code_probe_names[code_address] = probefunc();
	}
    }
}

probe process("/lib64/libc.so.6").function("mremap").return {
    if (pid() != target())
	next;
    old_size = 0;
    old_pointer = @defined(@entry($arg1)) ?
			   @entry($arg1) : @entry(register("rdi"));
    if (old_pointer) {
	old_size = pointer_sizes[old_pointer];
	delete pointer_sizes[old_pointer];
    }
    /* inline munmap */
    old_code_address = pointer_alloc_addresses_in_code[old_pointer];
    if (old_code_address) {
	handle_watch(old_code_address == watch_address,
		     old_pointer && old_pointer == watch_pointer);
	bytes_alloced_in_code_address[old_code_address] -= old_size;
	if (bytes_alloced_in_code_address[old_code_address] == 0) {
	    delete bytes_alloced_in_code_address[old_code_address];
	    forget(old_code_address);
	}
	if (verbose)
	    ++count_freed_in_code_address[old_code_address];
    }
    /* inline mmap */
    new_pointer = @defined($return) ? $return : register("rax");
    if (new_pointer != -1) {
	new_code_address = uaddr();
	handle_watch(new_code_address == watch_address,
		     new_pointer && new_pointer == watch_pointer);
	new_size = @defined(@entry($arg3)) ?
			    @entry($arg3) : @entry(register("rdx"));
	bytes_alloced_in_code_address[new_code_address] += new_size;
	pointer_alloc_addresses_in_code[new_pointer] = new_code_address;
	// assume new_size > 0
	pointer_sizes[new_pointer] = new_size;
	if (verbose) {
	    allocs[new_code_address] = n_mremap;
	    ++count_alloced_in_code_address[new_code_address];
	    if (verbose > 1)
		code_probe_names[new_code_address] = probefunc();
	}
    }
    else
	handle_invalid(old_pointer);
}

probe process("/lib64/libc.so.6").function("munmap") {
    if (pid() != target())
	next;
    pointer = @defined($arg1) ? $arg1 : register("rdi");
    size = @defined($arg2) ? $arg2 : register("rsi");
    /* These should only happen in glibc code, possibly due to memory
     * mapped with a direct syscall during binary load */
    /*
    if (pointer_sizes[pointer] != size) {
	printf("warning: munmap size difers: %ld - %ld\n",
	       pointer_sizes[pointer], size);
	print_ubacktrace();
    }
    */
    if (pointer_sizes[pointer])
	delete pointer_sizes[pointer];
    else
	handle_invalid(pointer);
    delete pointer_sizes[pointer];
    code_address = pointer_alloc_addresses_in_code[pointer];
    if (code_address) {
	handle_watch(code_address == watch_address,
		     pointer && pointer == watch_pointer);
	if (size) {
	    if (verbose)
		++count_freed_in_code_address[code_address];
	    bytes_alloced_in_code_address[code_address] -= size;
	    if (bytes_alloced_in_code_address[code_address] == 0) {
		delete bytes_alloced_in_code_address[code_address];
		forget(code_address);
	    }
	}
	delete pointer_alloc_addresses_in_code[pointer];
    }
}

function common_malloc(pointer, size, kind) {
    if (pointer) {
	if (size == 0)
	    handle_non_portable(pointer);
	code_address = uaddr();
	handle_watch(code_address == watch_address, pointer == watch_pointer);
	bytes_alloced_in_code_address[code_address] += size;
	pointer_alloc_addresses_in_code[pointer] = code_address;
	pointer_sizes[pointer] = size;
	if (verbose) {
	    allocs[code_address] = kind;
	    ++count_alloced_in_code_address[code_address];
	    if (verbose > 1) {
		code_probe_names[code_address] = probefunc();
		if (pointer >= break_start && pointer < break_end)
		    break_alloc += size;
	    }
	}
    }
}

probe
process("/lib64/libc.so.6").function("malloc").return,
process("/lib64/libc.so.6").function("valloc").return,	/* deprecated */
process("/lib64/libc.so.6").function("pvalloc").return	/* deprecated */
{
    if (pid() != target() || news[tid()])
	next;
    pointer = @defined($return) ? $return : register("rax");
    size = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
    common_malloc(pointer, size, n_malloc);
}

probe process("/lib64/libc.so.6").function("calloc").return {
    if (pid() != target() || news[tid()])
	next;
    pointer = @defined($return) ? $return : register("rax");
    number  = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
    count   = @defined(@entry($arg2)) ? @entry($arg2) : @entry(register("rsi"));
    size = number * count;
    if (pointer) {
	if (size == 0)
	    handle_non_portable(pointer);
	code_address = uaddr();
	handle_watch(code_address == watch_address, pointer == watch_pointer);
	bytes_alloced_in_code_address[code_address] += size;
	pointer_alloc_addresses_in_code[pointer] = code_address;
	pointer_sizes[pointer] = size;
	if (verbose) {
	    allocs[code_address] = n_calloc;
	    ++count_alloced_in_code_address[code_address];
	    if (verbose > 1) {
		code_probe_names[code_address] = probefunc();
		if (pointer >= break_start && pointer < break_end)
		    break_alloc += size;
	    }
	}
    }
}

function common_realloc(new_pointer, old_pointer, new_size, kind) {
    code_address = uaddr();
    old_code_address = pointer_alloc_addresses_in_code[old_pointer];
    if (old_code_address) {
	handle_watch(old_code_address == watch_address &&
		     old_code_address != code_address,
		     old_pointer && old_pointer != new_pointer &&
		     old_pointer == watch_pointer);
	delete pointer_alloc_addresses_in_code[old_code_address];
	old_size = pointer_sizes[old_pointer];
	delete pointer_sizes[old_pointer];
	bytes_alloced_in_code_address[old_code_address] -= old_size;
	if (verbose > 1 &&
	    old_pointer >= break_start && old_pointer < break_end)
	    break_alloc -= old_size;
	if (bytes_alloced_in_code_address[old_code_address] == 0) {
	    delete bytes_alloced_in_code_address[old_code_address];
	    forget(old_code_address);
	}
	if (verbose)
	    ++count_freed_in_code_address[old_code_address];
    }
    // assume no overflow
    bytes_alloced_in_code_address[code_address] += new_size;
    if (new_pointer) {
	if (new_size == 0)
	    handle_non_portable(new_pointer);
	handle_watch(code_address == watch_address,
		     new_pointer == watch_pointer);
	pointer_alloc_addresses_in_code[new_pointer] = code_address;
	pointer_sizes[new_pointer] = new_size;
	if (verbose) {
	    allocs[code_address] = kind;
	    ++count_alloced_in_code_address[code_address];
	    if (verbose > 1) {
		code_probe_names[code_address] = probefunc();
		if (new_pointer >= break_start && new_pointer < break_end)
		    break_alloc += new_size;
	    }
	}
    }
}

probe process("/lib64/libc.so.6").function("realloc") {
    if (pid() != target())
	next;
    check_signal();
    if (1 || realloc_null_is_malloc) {
	if (news[tid()])
	    next;
	news[tid()] = 1;
    }
}

probe process("/lib64/libc.so.6").function("realloc").return {
    if (pid() != target())
	next;
    new_pointer	= @defined($return) ? $return : register("rax");
    old_pointer = @defined(@entry($arg1)) ?
			   @entry($arg1) : @entry(register("rdi"));
    new_size	= @defined(@entry($arg2)) ?
			   @entry($arg2) : @entry(register("rsi"));
    common_realloc(new_pointer, old_pointer, new_size, n_realloc);
    if (realloc_null_is_malloc)
	delete news[tid()];
}

probe process("/lib64/libc.so.6").function("reallocarray").return {
    if (pid() != target())
	next;
    if (1 || reallocarray_is_realloc) {
	if (verbose)
	    allocs[uaddr()] = n_reallocarray;
    }
    else {
	new_pointer = @defined($return) ? $return : register("rax");
	old_pointer = @defined(@entry($arg1)) ?
			       @entry($arg1) : @entry(register("rdi"));
	number	    = @defined(@entry($arg2)) ?
			       @entry($arg2) : @entry(register("rsi"));
	count	    = @defined(@entry($arg3)) ?
			       @entry($arg3) : @entry(register("rdx"));
	new_size = number * count;
	common_realloc(new_pointer, old_pointer, new_size, n_reallocarray);
    }
}

probe process("/lib64/libc.so.6").function("posix_memalign").return {
    if (pid() != target() || news[tid()])
	next;
    result = @defined($return) ? $return : register("rax");
    if (result == 0) {
	pointer_to_pointer = @defined(@entry($arg1)) ?
				      @entry($arg1) : register("rdi");
	size		   = @defined(@entry($arg3)) ?
				      @entry($arg3) : register("rdx");
	code_address = uaddr();
	pointer = user_int64(pointer_to_pointer);
	handle_watch(code_address == watch_address,
		     pointer && pointer == watch_pointer);
	bytes_alloced_in_code_address[code_address] += size;
	pointer_alloc_addresses_in_code[pointer] = code_address;
	pointer_sizes[pointer] = size;
	if (verbose) {
	    allocs[code_address] = n_posix_memalign;
	    ++count_alloced_in_code_address[code_address];
	    if (verbose > 1) {
		code_probe_names[code_address] = probefunc();
		if (pointer >= break_start && pointer < break_end)
		    break_alloc += size;
	    }
	}
    }
}

probe
process("/lib64/libc.so.6").function("aligned_alloc").return,
process("/lib64/libc.so.6").function("memalign").return	/* deprecated */
{
    if (pid() != target() || news[tid()])
	next;
    pointer = @defined($return) ? $return : register("rax");
    size    = @defined(@entry($arg2)) ?
		       @entry($arg2) : @entry(register("rsi"));
    if (size && pointer) {
	code_address = uaddr();
	handle_watch(code_address == watch_address, pointer == watch_pointer);
	bytes_alloced_in_code_address[code_address] += size;
	pointer_alloc_addresses_in_code[pointer] = code_address;
	pointer_sizes[pointer] = size;
	if (verbose) {
	    allocs[code_address] = n_aligned_alloc;
	    ++count_alloced_in_code_address[code_address];
	    if (verbose > 1) {
		code_probe_names[code_address] = probefunc();
		if (pointer >= break_start && pointer < break_end)
		    break_alloc += size;
	    }
	}
    }
}

function common_free(pointer) {
    size = pointer_sizes[pointer];
    if (pointer)
	delete pointer_sizes[pointer];
    code_address = pointer_alloc_addresses_in_code[pointer];
    if (code_address) {
	/* Should be invalid if attaching to process or something
	 * like an destructor after a dlclose call */
	handle_watch(code_address == watch_address,
		     pointer && pointer == watch_pointer);
	if (size) {
	    if (verbose) {
		++count_freed_in_code_address[code_address];
		if (verbose > 1 &&
		    pointer >= break_start && pointer < break_end)
		    break_alloc -= size;
	    }
	    bytes_alloced_in_code_address[code_address] -= size;
	    if (bytes_alloced_in_code_address[code_address] == 0) {
		delete bytes_alloced_in_code_address[code_address];
		forget(code_address);
	    }
	}
	delete pointer_alloc_addresses_in_code[pointer];
    }
    else if (pointer)
	handle_invalid(pointer);
}

probe process("/lib64/libc.so.6").function("free") {
    if (pid() != target() || deletes[tid()])
	next;
    check_signal();
    pointer = @defined($arg1) ? $arg1 : register("rdi");
    common_free(pointer);
}

probe
/*
// operator new[](unsigned long, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZnamSt11align_val_t"),
// operator new(unsigned long, std::align_val_t, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZnwmSt11align_val_tRKSt9nothrow_t"),
// operator new(unsigned long, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZnwmRKSt9nothrow_t"),
// operator new[](unsigned long, std::align_val_t, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZnamSt11align_val_tRKSt9nothrow_t"),
// operator new[](unsigned long)
process("/lib64/libstdc++.so.6").function("_Znam"),
// operator new[](unsigned long, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZnamRKSt9nothrow_t"),
 */
// operator new(unsigned long, std::align_val_t) -- posix_memalign
process("/lib64/libstdc++.so.6").function("_ZnwmSt11align_val_t"),
// operator new(unsigned long) -- malloc
process("/lib64/libstdc++.so.6").function("_Znwm")
{
    if (pid() != target())
	next;
    check_signal();
    news[tid()] = 1;
}

probe
/*
process("/lib64/libstdc++.so.6").function("_ZnwmSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_ZnwmRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZnwmSt11align_val_tRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZnamSt11align_val_tRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_Znam").return,
process("/lib64/libstdc++.so.6").function("_ZnamRKSt9nothrow_t").return,
 */
process("/lib64/libstdc++.so.6").function("_ZnamSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_Znwm").return
{
    if (pid() != target())
	next;
    pointer = @defined($return) ? $return : register("rax");
    size    = @defined(@entry($arg1)) ?
		       @entry($arg1) : @entry(register("rdi"));
    common_malloc(pointer, size, n_new);
    delete news[tid()];
}

probe
/*
// operator delete(void*, std::align_val_t, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZdlPvSt11align_val_tRKSt9nothrow_t"),
// operator delete(void*, unsigned long)
process("/lib64/libstdc++.so.6").function("_ZdlPvm"),
// operator delete[](void*, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZdaPvRKSt9nothrow_t"),
// operator delete(void*, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZdlPvRKSt9nothrow_t"),
// operator delete[](void*, std::align_val_t, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZdaPvSt11align_val_tRKSt9nothrow_t"),
// operator delete(void*, unsigned long, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZdlPvmSt11align_val_t"),
// operator delete[](void*)
process("/lib64/libstdc++.so.6").function("_ZdaPv"),
// operator delete(void*, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZdlPvSt11align_val_t"),
// operator delete[](void*, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZdaPvSt11align_val_t"),
// operator delete[](void*, unsigned long)
process("/lib64/libstdc++.so.6").function("_ZdaPvm"),
// operator delete[](void*, unsigned long, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZdaPvmSt11align_val_t"),
 */
// operator delete(void*) -- free
process("/lib64/libstdc++.so.6").function("_ZdlPv")
{
    if (pid() != target())
	next;
    check_signal();
    deletes[tid()] = 1;
    pointer = @defined($arg1) ? $arg1 : register("rdi");
    common_free(pointer);
}

probe
/*
process("/lib64/libstdc++.so.6").function("_ZdlPvSt11align_val_tRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZdlPvm").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZdlPvRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvSt11align_val_tRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZdlPvmSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_ZdaPv").return,
process("/lib64/libstdc++.so.6").function("_ZdlPvSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvm").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvmSt11align_val_t").return,
 */
process("/lib64/libstdc++.so.6").function("_ZdlPv").return
{
    if (pid() != target())
	next;
    delete deletes[tid()];
}

function allocator:string(address:long) {
    value = allocs[address];
    if (value == n_mmap)		return "mmap";
    if (value == n_mremap)		return "mremap";
    if (value == n_malloc)		return "malloc";
    if (value == n_calloc)		return "calloc";
    if (value == n_realloc)		return "realloc";
    if (value == n_reallocarray)	return "reallocarray";
    if (value == n_posix_memalign)	return "posix_memalign";
    if (value == n_aligned_alloc)	return "aligned_alloc";
    if (value == n_new)			return "operator new";
    return "???";
}

/* Note that what is listed are not leaks, but allocated memory, that
 * could/should be reachable. */
function report() {
    total = 0;
    total_nomap = 0;
    break_range = break_end - break_start;
    printf("\nReport for %s (%s)\n", process_name, process_arguments);
    if (verbose) {
	if (verbose > 2) {
	    foreach (pointer in pointer_alloc_addresses_in_code)
		detailed_report[pointer_alloc_addresses_in_code[pointer]] .=
		    sprintf(" %p(%d)", pointer, pointer_sizes[pointer]);
	}
	printf("%16s\t      Count     \t%-16s\t%s\n", "Size", "Allocator", "Code Address");
	printf("------------------------------------------------------------------------------------------------\n");
	foreach (address in bytes_alloced_in_code_address) {
	    bytes = bytes_alloced_in_code_address[address];
	    total += bytes;
	    if (verbose > 1 &&
		allocs[address] != n_mmap &&
		allocs[address] != n_mremap)
		total_nomap += bytes;
	    printf("%16ld\t%8d-%-8d\t%-16s\t%s",
		   bytes,
		   count_alloced_in_code_address[address],
		   count_freed_in_code_address[address],
		   allocator(address),
		   usymfileline(address));
	    /* do not print address twice */
	    if (verbose > 1) {
		if (!strtol(code_probe_names[address], 16))
		    printf(" (%s)", code_probe_names[address]);
		else
		    printf("  - ");
		if (verbose > 2) {
		    printf("%s", detailed_report[address]);
		    length = strlen(detailed_report[address]);
		    detailed_report[address] .= " ";
		    if (length == strlen(detailed_report[address])) {
			string_truncate_length = length + 1;
			printf("...");
		    }
		    delete detailed_report[address];
		}
	    }
	    printf("\n");
	}
    }
    else {
	printf("%16s\t%s\n", "Size", "Code Address");
	printf("------------------------------------------------\n");
	foreach (address in bytes_alloced_in_code_address) {
	    bytes = bytes_alloced_in_code_address[address];
	    total += bytes;
	    printf("%16ld\t%s\n", bytes, usymfileline(address));
	}
    }
    /*   Bogus total is bogus amount of memory not released - it is bogus
     * because does not account for alignment, nor if the memory is from
     * mmap or the main arena.
     *   It also does not qualify as leaks at exit, as the memory might
     * be reachable. */
    printf("Bogus Total %54ld (%16p)\n", total, total);
    printf("Bogus Break [%-16p-%16p] = %16ld (%16p)\n", break_start, break_end,
	   break_range, break_range);
    if (verbose > 1) {
	printf("Bogus Heap  %54ld (%16p)\n", break_alloc, break_alloc);
	printf("Bogus NoMap %54ld (%16p)\n", total_nomap, total_nomap);
    }
}

probe signal.send {
    if (sig_name == "SIGURG" && sig_pid == target())
	report();
}

probe signal.handle {
    if (pid() != target() || sig_name == "SIGTRAP" ||
	sig_name == "SIGSTOP" || sig_name == "SIGTSTP")
	next;
    handling_signal = sig;
}

probe process("/lib64/libc.so.6").function("__restore_rt") {
    if (pid() != target())
	next;
    handling_signal = 0;
}

function reset() {
    delete pointer_alloc_addresses_in_code;
    delete pointer_sizes;
    if (verbose) {
	delete bytes_alloced_in_code_address;
	delete count_alloced_in_code_address;
	delete count_freed_in_code_address;
	delete code_probe_names;
	delete allocs;
	if (verbose > 1) {
	    delete code_probe_names;
	    /* Should be empty or only include entries where
	     * bytes_alloced_in_code_address[detailed_report[address]] == 0 */
	    if (verbose > 2)
		delete detailed_report;
	}
    }
    break_start = break_end = break_alloc = 0;

}

probe kprocess.exec {
    if (pid() != target())
	next;
    exec_process_arguments = argstr;
}

probe kprocess.exec_complete {
    if (pid() != target())
	next;
    if (success) {
	if (process_name != "") {
	    report();
	    reset();
	}
	process_name = execname();
	process_arguments = exec_process_arguments;
    }
}

probe end {
    report();
    if (verbose > 2 && string_truncate_length)
	printf("There were truncated reports (ending with ...). Rerun with -DMAXSTRINGLEN=N with N larger than %ld for more data.\n",
	       string_truncate_length);
    printf("Stap done.\n");
    reset();
}
