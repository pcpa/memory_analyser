#!/usr/bin/stap

/*
 - Simple memory usage diagnostics tool, requires glibc  and libstdc++
 - As long as systemtap works during execution, otherwise see:
   https://sourceware.org/systemtap/wiki/TipExhaustedResourceErrors
   it should only not list memory allocated with direct syscalls or
   get confused with munmap calls that release partial amounts of memory
 - Calls to mmap actually maping a file in memory might also end
   with inconsistent results

 - Once the program exits, or receives a SIGURG, a diagnostic is printed of
   all known memory allocations.
 - The script attempts to do its best to keep track of memory allocation and
   release to avoid printing misleading data, but it almost certainly has
   bugs.

 To match the code address, you might temporarily run:
 # echo 0 > /proc/sys/kernel/randomize_va_space
 or after a kill -URG attach gdb to the process and disassemble the address.
 Backtraces are not saved, otherwise the tool would be only useful for very
 small binaries.
 The tool/script attempts to have some use by saving the return address of
 the memory allocation routine.

 Works only on x86_64. Does not really need glibc nor libstdc++ debuginfo,
 as it takes values direct from registers, and due to this, needs to know
 about the abi.

 Should work at least on RHEL8, RHEL9 and Fedora 39.
 Likely to "bitrot" in a few years and/or Linux releases.

 Preparing to run:
 # dnf install -y systemtap
 # stap-prep

 Running the script:
 # stap -DMAXMAPENTRIES=262144 -DSTP_OVERLOAD_THRESHOLD=1073741824LL -DSTP_OVERLOAD_INTERVAL=2147483648LL -DMAXACTION=16384 memory.stp -c $COMMAND
 (( note the options, that otherwise, will fail for not so large binaries ))

 Forcing printing diagnostics:
 # kill -URG $(pidof $COMMAND)

 Checking the code:
 # gdb -p $(pidof $COMMAND)

 In gdb, can check addresses with something like:
 (gdb) x/20i $ADDRESS-32
 or
 (gdb) disassemble $ADDRESS

  Sample output with full verbose mode:

$ stap -DMAXMAPENTRIES=262144 -Gverbose=3 -DSTP_OVERLOAD_THRESHOLD=1073741824LL -DSTP_OVERLOAD_INTERVAL=2147483648LL -DMAXACTION=65536 -DMAXSTRINGLEN=4096 memory.stp -c /bin/ls
Stap ready.
memory.stp  README
Stap done.

            Size	      Count     	Allocator       	Code Address
------------------------------------------------------------------------------------------------
             166	      15-1       	malloc          	0x7f20867f260f (strdup) 0x555d562f62c0(12) 0x555d562f7240(12) 0x555d562f7260(12) 0x555d562f7280(12) 0x555d562f72a0(12) 0x555d562f72c0(12) 0x555d562f72e0(12) 0x555d562f7300(12) 0x555d562f7320(12) 0x555d562f7340(12) 0x555d562f7360(12) 0x555d562f7380(12) 0x555d562f73a0(12) 0x555d562f7410(10)
       224366320	       1-0       	mmap            	0x7f2086782752 (_nl_load_locale_from_archive) 0x7f2079000000(224366320)
             120	       1-0       	malloc          	0x7f20867824f4 (_nl_load_locale_from_archive) 0x555d562f62e0(120)
             792	       1-0       	malloc          	0x7f2086781950 (_nl_intern_locale_data) 0x555d562f6360(792)
            2864	      11-0       	malloc          	0x7f2086781863 (_nl_intern_locale_data) 0x555d562f6680(104) 0x555d562f66f0(1328) 0x555d562f6c30(208) 0x555d562f6d10(424) 0x555d562f6ec0(96) 0x555d562f6f30(80) 0x555d562f6f90(112) 0x555d562f7010(160) 0x555d562f70c0(96) 0x555d562f7130(72) 0x555d562f7180(184)
              12	       1-0       	malloc          	0x7f20867806ac (new_composite_name) 0x555d562f73c0(12)
              34	       1-0       	malloc          	0x7f2086784393 (set_binding_values.part.0) 0x555d562f73e0(34)
             112	       2-0       	malloc          	0x555d2d3869cc  -  0x555d562f7430(56) 0x555d562f7470(56)
             128	       1-0       	malloc          	0x555d2d37e65a (tzalloc) 0x555d562f74b0(128)
           20800	       1-0       	reallocarray    	0x555d2d37a3a7 (main) 0x555d562f7540(20800)
              18	       3-1       	malloc          	0x555d2d38653f (xstrdup) 0x555d56304720(7) 0x555d56304740(11)
              48	       1-0       	reallocarray    	0x555d2d383f21 (sort_files) 0x555d562fc6e0(48)
              96	       1-0       	reallocarray    	0x555d2d384c9c  -  0x555d562fc720(96)
              80	       1-0       	reallocarray    	0x555d2d384cf2  -  0x555d562fc790(80)
Bogus Total                                              224391590 (       0xd5ff1a6)
Bogus Break [0x555d562f6000  -  0x555d56317000] =           135168 (         0x21000)
Bogus Heap                                                   25270 (          0x62b6)
Bogus NoMap                                                  25270 (          0x62b6)

  Bogus Total is accounted memory not released
  Bogus Break is accounted memory in main arena
  Bogus Heap  is accounted memory in use and allocated from main arena
  Bogus NoMap is accounted memory not released but not allocated with m(re)map

  For single threaded applications, Bogus Heap and Bogus NoMap should have
  the same value on normal conditions (sans bugs or conditions not handled).
  For multithreaded applications usually Bogus NoMap will have a higher value,
  depending on memory not released by thread and/or if the application exits
  without joining all threads.

  Note that "not released" does not mean a detected leak. The memory usually
  should be reachable; this script does not attempt to check if pointers are
  reachable during report. The kernel eventually will release all memory when
  the application exits. Still, the closer to 0 is left as Bogus Heap and
  Bogus NoMap the closer to leak free the binary is.

  Note that the call to probefunc() is better than ppfunc() because probefunc()
  was the best I could get to some symbolic information in verbose mode.

 Author:	Paulo Cesar Pereira de Andrade
 */

global bytes_alloced_in_code_address;
global pointer_alloc_addresses_in_code;
global pointer_release_address_in_code;
global pointer_sizes;
global mmap_sizes;
global %(guru_mode != 0 %? mmap_filenames %: mmap_fds %);
global mmap_prots;
global mmap_starts;
global mmap_offsets;
global detailed_report;
global string_truncate_length;
global process_name = "";
global process_path = "";
global process_arguments, exec_process_arguments;

/* Bogus malloc main_arena area information */
global break_start;
global break_end;
global break_alloc = 0;

/* -Gverbose=1 to print allocator names */
global verbose = 0;

/* Unless there is a special need, these "watch points" should be direct
 * variables, instead of a list of values, what would require a hash table
 * lookup. These are only meaningful with address randomization disabled. */
/* -Gwatch_address=<address> to print user backtrace when allocating
 * from the given address */
global watch_address = 0;
/* -Gwatch_pointer=<pointer> to print user backtrace when an allocation
 * returns the given pointer.*/
global watch_pointer = 0;
/* -Gtrap_on_watch=1 to raise SIGTRAP if one of the pseudo watchpoints
 * is reached. This requires running systemtap in guru mode. */
global trap_on_watch = 0;
/* -Gshow_invalid=1 to print an backtrace if an invalid pointer is passed
 * to free/mremap/realloc. Note that this obviously should only be used
 * if not attaching to a running process, otherwise it might trap on
 * valid data. */
global show_invalid = -1;
/* -Gshow_non_portable=1 to print a backtrace if passing zero as size for
 * memory allocation. Glibc returns a valid pointer, but other libcs
 * can return NULL. */
global show_non_portable = 0;
/* -Gtrap_on_invalid=1 to raise SIGTRAP if an invalid pointer is passed
 * to free/mremap/realloc. Note that this obviously should only be used
 * if not attaching to a running process, otherwise it might trap on
 * valid data. */
global trap_on_invalid = 0;
/* -Gworkaround_glibc=0 to possibly show invalid/unknown pointer, in the
 * pattern:

Invalid/unknown pointer 0x7fffd0001150
 0x7fffed369360 : cfree@GLIBC_2.2.5+0x0/0x110 [/usr/lib64/libc.so.6]
 0x7fffed3694cb : __malloc_arena_thread_freeres+0x5b/0x150 [/usr/lib64/libc.so.6]
 0x7fffed35870f : start_thread+0x16f/0x480 [/usr/lib64/libc.so.6]
 0x7fffed3dfa5c : __GI___clone3+0x2c/0x50 [/usr/lib64/libc.so.6]

  This happens because __malloc_arena_thread_freeres() calls
  tcache_thread_shutdown(), that has:

    tcache_perthread_struct *tcache_tmp = tcache;
and after releasing all tcache entries with _libc_free() finally calls:
  __libc_free (tcache_tmp);

 The problem is that malloc/malloc.c has:
static __thread tcache_perthread_struct *tcache = NULL;
and tcache_init() calls _int_malloc(), not _libc_malloc() to initialize it.

  Another case is munmap call from a block directly allocated with a mmap
sycall, when creating a new arena. A warning would be printed for every
arena created.
 */
global workaround_glibc = 1;

/* -Grecord_double_free=1 to record last release of a pointer,  making it
 * easier to debug an Invalid/unknown pointer message.
 * Unless explicitly set, the default value is true if verbose > 2 and
 * did not attach to a running process, false otherwise. */
global record_double_free = -1;

/* -Gshow_mmap_syscalls=1 to display information about mmap and munmap
 * calls not done using the mmap and munmap glibc calls. */
global show_mmap_syscalls = 0;
/* -Gshow_nested_mmap_syscalls=1 to also display information about mmap
 * and munmap syscalls that are also probed in the mmap and munmap glibc
 * calls. The show_mmap_syscalls option is not explicitly set if this
 * one is set, to allow only further debugging calls through glibc,
 * that might not be related to allocating raw memory, but mapping files
 * in memory, and ignore mmap related calls during shared object loading. */
global show_nested_mmap_syscalls = 0;
/* Note that while there are two mmap syscall related options, that enable
 * 4 states, output can be confusing because glibc in several points has
 * mmap function calls (that are as expected probed as function calls) but
 * instead of a matching munmap, have a direct munmap syscall releasing the
 *  memory. */
/* -Gworkaround_mmap_mismatch=1 to workaround patterns
 *	syscall.mmap - process.munmap
 *	process.mmap - syscall.munmap
 * Note that this might lead to errors in the pattern:
 * ERROR: reached end of stack before unwinding to level 1
 * If this happen, either run with -Gworkaround_mmap_mismatch=0
 * or --suppress-handler-errors
 */
global workaround_mmap_mismatch = 0;
/* -Gignore_mmap=1 to ignore all mmap calls. Computing mmap might lead to
 * double probes, or very complex code. Disabling it should make the probes
 * faster due to less checks being done. */
global ignore_mmap = 0;
/* -Gignore_mmap_during_alloc=0 to not ignore mmap calls during memory
 * allocation or release. Mmap might be used to either serve a large memory
 * allocation request, or create a heap. */
global ignore_mmap_during_alloc = 1;
global doing_memory_allocation;

global start_gdbserver = 0;
global gdbserver_port = 1234;
/* Do not use -Gbinary_path_for_gdbserver as it needs to match the regex
 * 	"^[a-z_][a-z0-9_]*=[a-z0-9_.-]+$"
 * instead, pass it in the command line, for example:
 * $ stap -Gstart_gdbserver=1 ... memory.stp -c wrapper_script /usr/bin/binary
 * where processes in wrapper_script will be executed, and, when
 * /usr/bin/binary is executed, gdbserver will be spawned and attach to it.
 */
global binary_path_for_gdbserver = "";

/* Start pretending it did attach to running process. Changed in begin probe, */
global attached = 1;

/* avoid realloc return probe computed twice */
global realloc_null_is_malloc = 1;
/* avoid reallocarray and realloc return probes being computed */
global reallocarray_is_realloc = 1;

/* avoid double stats */
global news;
global deletes;
global mmaps;
global munmaps;
global mmap_lengths;

%( 1 == 1 /* tcmalloc */ %?
global tc_news;
global tc_deletes;
  %)

%( 2 == 2 /* mimalloc */ %?
global mi_deletes;
  %)

/* alloc type in verbose mode */
global allocs;

/* set while in a signal handler context */
global handling_signal;

/* Number of alloc hits in verbose mode */
global count_alloced_in_code_address;
/* Number of release hits in verbose mode */
global count_freed_in_code_address;
/* Approximate probe name in verbose name */
global code_probe_names;

/* constants (kind of) */
global n_syscall = 0;
global n_mmap = 1;
global n_mremap = 2;
global n_malloc = 3;
global n_calloc = 4;
global n_realloc = 5;
global n_reallocarray = 6;
global n_posix_memalign = 7;
global n_aligned_alloc = 8;
global n_new = 9;
%( 0 == 0 /* jemalloc */ %?
 global n_je_malloc = 10;
 global n_je_calloc = 11;
 global n_je_realloc = 12;
 global n_je_posix_memalign = 13;
 global n_je_aligned_alloc = 14;
 %)
%( 1 == 1 /* tcmalloc */ %?
  global n_tc_mmap = 15;
  global n_tc_mremap = 16;
  global n_tc_malloc = 17;
  global n_tc_calloc = 18;
  global n_tc_realloc = 19;
  global n_tc_reallocarray = 20;
  global n_tc_posix_memalign = 21;
  global n_tc_aligned_alloc = 22;
  global n_tc_new = 23;
  %)
%( 2 == 2 /* mimalloc */ %?
      global n_mi_malloc = 24;
      global n_mi_calloc = 25;
      global n_mi_realloc = 26;
      global n_mi_reallocarray = 27;
      global n_mi_posix_memalign = 28;
      global n_mi_aligned_alloc = 29;
      global n_mi_strdup = 30;
      global n_mi_new = 31;
  %)

probe begin {
    tokenize(cmdline_str(), " ");
    token = tokenize("", " ");
    attached = token != "-c";
    if (attached && token != "-t") {
	error(sprintf("Failed to tokenize command line.\n"
		      "Cannot run system wide. "
		      "Must use '-c CMD' or '-x PID'.\n"
		      "cmdline_str() returns <%s>\n",
		      cmdline_str()));
    }
    if (attached && start_gdbserver) {
	token = tokenize("", " ");
	pid = strtol(token, 10);
	process_path = pid2execname(pid);
	run_gdbserver(pid);
    }
    /* Make it easier to attach gdb to the proper process, if it is run
     * by some wrapper script or exec'ed (e.g. env ENV=val binary).
     * Note that full path is expected to specified here. */
    %( $# >= 1 %?
      else if (start_gdbserver)
	  binary_path_for_gdbserver = @1;
	  %)
    if (attached && trap_on_invalid)
	printf("-Gtrap_on_invalid might generate false positives when attaching to a pid.");
    if (show_invalid == -1)
	show_invalid = trap_on_invalid || !attached;
    if (record_double_free == -1)
	record_double_free = verbose > 2 && !attached;
    printf("Stap ready.\n");
}

function handle_watch(handle_address, handle_pointer) {
    if (handle_address && handle_pointer)
	printf("\nWatch address %p - pointer %p:\n",
	       watch_address, watch_pointer);
    else if (handle_address)
	printf("\nWatch address %p:\n", watch_address);
    else if (handle_pointer)
	printf("\nWatch pointer %p:\n", watch_pointer);
    else
	return;
    print_ubacktrace();
    %(guru_mode != 0 %?
      if (trap_on_watch) raise(%{ SIGTRAP %}) %:
	  if (trap_on_watch) printf("trap_on_watch needs guru mode\n")
	  %);
}

%( guru_mode != 0 %?
  function task_file_handle_d_path:string (task:long, fd:long)
  %{ /* pure */
      struct task_struct *p = (struct task_struct *)((long)STAP_ARG_task);
      struct files_struct *files;
      char *page = NULL;
      struct file *filp;
      struct dentry *dentry;
      struct vfsmount *vfsmnt;
      char *path = NULL;

      rcu_read_lock();
      if ((files = kread(&p->files)) &&
	  // We need GFP_ATOMIC since we're inside a lock so we
	  // can't sleep.
	  (page = (char *)__get_free_page(GFP_ATOMIC)) &&
	  (
#ifdef STAPCONF_FILES_LOOKUP_FD_RAW
	   filp = files_lookup_fd_raw(files, STAP_ARG_fd)
#else
	   filp = fcheck_files(files, STAP_ARG_fd)
#endif
	   )) {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
	  /* git commit 9d1bc601 */
	  path = d_path(&filp->f_path, page, PAGE_SIZE);
#else
	  dentry = kread(&filp->f_dentry);
	  vfsmnt = kread(&filp->f_vfsmnt);

	  if (dentry && vfsmnt) {
	      path = d_path(dentry, vfsmnt, page, PAGE_SIZE);
	  }
#endif
	  if (path && !IS_ERR(path)) {
	      snprintf(STAP_RETVALUE, MAXSTRINGLEN, "%s", path);
	  }
      }
      CATCH_DEREF_FAULT();

      if (page) free_page((unsigned long)page);

      rcu_read_unlock();
      %}
  %: %)


function handle_invalid(pointer) {
    if (show_invalid) {
	if (workaround_glibc) {
	    /* The tcache per thread variable is free'd with a free call, but
	     * allocated with a short-circuit call to _int_malloc.
	     */
	    backtrace = sprint_ubacktrace();
	    if (backtrace =~ "__malloc_arena_thread_freeres+" ||
		(backtrace =~ "__munmap+" && backtrace =~ "alloc_new_heap+") ||
		(backtrace =~ "__munmap+" && backtrace =~ "__nptl_free_stacks+"))
		return;
	}
	printf("\nInvalid/unknown pointer %p\n", pointer);
	print_ubacktrace();
	if (record_double_free && pointer_release_address_in_code[pointer]) {
	    printf("Pointer marked as released at code address %p",
		   pointer_release_address_in_code[pointer]);
	    data = usymdata(pointer_release_address_in_code[pointer]);
	    if (!strtol(data, 16))
		printf(" (%s)", data);
	    printf("\n");
	}
	%(guru_mode != 0 %?
	  if (trap_on_invalid) raise(%{ SIGTRAP %}) %:
	      if (trap_on_invalid) printf("trap_on_invalid needs guru mode\n")
		  %);
    }
}

function handle_non_portable(pointer) {
    if (show_non_portable)
	print_ubacktrace();
}

function check_signal() {
    if (handling_signal) {
	backtrace = sprint_ubacktrace();
	/* This is fragile. A thread not handling the signal is fine
	 * allocating/releasing memory.  */
	if (backtrace =~ "__restore_rt+") {
	    printf("\nMemory allocation/deallocation during %s signal handler\n",
		   signal_str(handling_signal));
	    print_ubacktrace();
	}
    }
}

function run_gdbserver(pid) {
    system(sprintf("gdbserver --attach :%d %d",
		   gdbserver_port, pid));
    printf("To attach gdb, run in the command line\n$ gdb %s\n",
	   process_path);
    printf("In gdb prompt type:\n(gdb) target remote :%d\n\n",
	   gdbserver_port);
}

function ucaller_address:long() {
    try {
	caller = ucallers(1);
    }
    catch {
	caller = "";
    };
    addr = tokenize(caller, " ");
    addr = tokenize("", " ");
    return strtol(addr, 16);
}

function align_page_size:long(length) {
    return (length + (mem_page_size() - 1)) & -mem_page_size();
}

probe
process("/lib64/libc.so.6").function("brk"),
process("/lib64/libc.so.6").function("sbrk"),
process("/lib64/libc.so.6").function("mremap")
{
    if (pid() != target())
	next;
    check_signal();
}

probe
process("/lib64/libc.so.6").function("malloc"),
process("/lib64/libc.so.6").function("valloc"),
process("/lib64/libc.so.6").function("pvalloc"),
process("/lib64/libc.so.6").function("calloc"),
process("/lib64/libc.so.6").function("posix_memalign"),
process("/lib64/libc.so.6").function("aligned_alloc"),
process("/lib64/libc.so.6").function("memalign")
{
    if (pid() != target())
	next;
    check_signal();
    ++doing_memory_allocation[tid()];
}

probe process("/lib64/libc.so.6").function("brk").return {
    if (pid() != target())
	next;
    result = @defined($return) ? $return : register("rax");
    if (result == 0) {
	pointer = @defined(@entry($arg1)) ?
			   @entry($arg1) : @entry(register("rdi"));
	handle_watch(uaddr() == watch_address,
		     pointer && pointer == watch_pointer);
	if (break_start == 0 || pointer < break_start)
	    break_start = pointer;
	if (break_end == 0 || pointer > break_end)
	    break_end = pointer;
    }
}

probe process("/lib64/libc.so.6").function("sbrk").return {
    if (pid() != target())
	next;
    pointer = @defined($return) ? $return : register("rax");
    if (pointer != -1) {
	handle_watch(uaddr() == watch_address,
		     pointer && pointer == watch_pointer);
	/*
	increment = @defined(@entry($arg1)) ?
			     @entry($arg1) : @entry(register("rdi"));
	 */
	if (break_start == 0 || pointer < break_start)
	    break_start = pointer;
	if (break_end == 0 || pointer > break_end)
	    break_end = pointer;
    }
}

function forget(address:long) {
    /* Avoid remembering non useful information for too long */
    delete bytes_alloced_in_code_address[address];
    if (verbose)
	delete allocs[address];
}

probe syscall.mmap2 {
    if (ignore_mmap || pid() != target() ||
	(ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	next;
    if (workaround_mmap_mismatch ||
	(show_mmap_syscalls && !mmaps[tid()]) ||
	(show_nested_mmap_syscalls && mmaps[tid()])) {
	/* FIXME could not recover it in the return probe */
	mmap_lengths[tid()] = length;
	mmap_starts[tid()] = start;
	mmap_offsets[tid()] = pgoffset;
	mmap_prots[tid()] = prot;
	%(guru_mode != 0 %?
	  if (fd >= 0)
	      mmap_filenames[tid()] =
		task_file_handle_d_path(pid2task(tid()), fd)
	      %: mmap_fds[tid()] = fd %);
    }
}

probe syscall.mmap2.return {
    if (ignore_mmap || pid() != target() ||
	(ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	next;
    pointer = @defined($return) ? $return : register("rax");
    if (pointer != -1) {
	if (!mmaps[tid()] && workaround_mmap_mismatch)
	    common_mmap(pointer, mmap_lengths[tid()], n_syscall);
	if ((show_mmap_syscalls && !mmaps[tid()]) ||
	    (show_nested_mmap_syscalls && mmaps[tid()])) {
	    printf("%ssyscall   MMAP(%p, %12d",
		   mmaps[tid()] ? "*" : " ",
		   pointer, mmap_lengths[tid()]);
	    %(guru_mode != 0 %?
	      if (mmap_filenames[tid()] != "") {
		  printf(", %s", mmap_filenames[tid()]);
		  delete mmap_filenames[tid()]
	      } %:
	      if (mmap_fds[tid()] >= 0)
		  printf(", %ld", mmap_fds[tid()]);
	      delete mmap_fds[tid()] %);
	    if (mmap_starts[tid()])
		printf(", %p", mmap_starts[tid()]);
	    delete mmap_starts[tid()];
	    printf(", %s%s%s",
		   mmap_prots[tid()] & 1 ? "r" : "-",
		   mmap_prots[tid()] & 2 ? "w" : "-",
		   mmap_prots[tid()] & 4 ? "x" : "-");
	    delete mmap_prots[tid()];
	    if (mmap_offsets[tid()])
		printf(", %ld", mmap_offsets[tid()]);
	    delete mmap_offsets[tid()];
	    printf(")\n");
	}
	delete mmap_lengths[tid()];
    }
    delete mmaps[tid()];
}

probe syscall.munmap {
    if (ignore_mmap || pid() != target() ||
	(ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	next;
      if (!munmaps[tid()] && workaround_mmap_mismatch)
	  common_munmap(start, length, n_syscall);
      if ((show_mmap_syscalls && !munmaps[tid()]) ||
	  (show_nested_mmap_syscalls && munmaps[tid()]))
	  printf("%ssyscall MUNMAP(%p, %12ld)\n",
		 munmaps[tid()] ? "*" : " ",
		 start, length);
}

probe syscall.munmap.return {
    if (ignore_mmap || pid() != target() ||
	(ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	next;
    delete munmaps[tid()];
}

function common_mmap(pointer, size, kind) {
    size = align_page_size(size);
    code_address = uaddr();
    handle_watch(code_address == watch_address,
		 pointer && pointer == watch_pointer);
    bytes_alloced_in_code_address[code_address] += size;
    pointer_alloc_addresses_in_code[pointer] = code_address;
    pointer_sizes[pointer] = mmap_sizes[pointer] = size;
    if (verbose) {
	allocs[code_address] = kind;
	++count_alloced_in_code_address[code_address];
	if (verbose > 1)
	    code_probe_names[code_address] = probefunc();
    }
}

probe process("/lib64/libc.so.6").function("mmap") {
    if (ignore_mmap || pid() != target() ||
	(ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	next;
    check_signal();
    mmaps[tid()] = 1;
}

probe process("/lib64/libc.so.6").function("mmap").return {
    if (ignore_mmap || pid() != target() ||
	(ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	next;
    pointer = @defined($return) ? $return : register("rax");
    if (pointer != -1) {
	size = @defined(@entry($arg2)) ?
			@entry($arg2) : @entry(register("rsi"));
	common_mmap(pointer, size, n_mmap);
    }
}

function common_mremap(new_pointer, old_pointer, new_size, old_size, kind) {
    new_size = align_page_size(new_size);
    old_size = align_page_size(old_size);
    recorded_old_size = 0;
    if (old_pointer) {
	recorded_old_size = mmap_sizes[old_pointer];
	delete mmap_sizes[old_pointer];
	delete pointer_sizes[old_pointer];
    }
    /* inline munmap */
    old_code_address = pointer_alloc_addresses_in_code[old_pointer];
    if (old_code_address) {
	handle_watch(old_code_address == watch_address,
		     old_pointer && old_pointer == watch_pointer);
	if (recorded_old_size != old_size)
	    printf("Change in old size argument for mremap %ld - %ld\n",
		   recorded_old_size, old_size);
	bytes_alloced_in_code_address[old_code_address] -= old_size;
	if (bytes_alloced_in_code_address[old_code_address] == 0)
	    forget(old_code_address);
	if (verbose)
	    ++count_freed_in_code_address[old_code_address];
    }
    /* inline mmap */
    if (new_pointer != -1) {
	/* FIXME Is there some scenario where it can end up with no new map
	 * and invalidated old map? */
	if (record_double_free && old_pointer != new_pointer)
	    pointer_release_address_in_code[old_pointer] = ucaller_address();
	new_code_address = uaddr();
	handle_watch(new_code_address == watch_address,
		     new_pointer && new_pointer == watch_pointer);
	bytes_alloced_in_code_address[new_code_address] += new_size;
	pointer_alloc_addresses_in_code[new_pointer] = new_code_address;
	// assume new_size > 0
	pointer_sizes[new_pointer] = mmap_sizes[new_pointer] = new_size;
	if (verbose) {
	    allocs[new_code_address] = kind;
	    ++count_alloced_in_code_address[new_code_address];
	    if (verbose > 1)
		code_probe_names[new_code_address] = probefunc();
	}
    }
    else
	handle_invalid(old_pointer);
}

probe process("/lib64/libc.so.6").function("mremap").return {
    if (ignore_mmap || pid() != target() ||
	(ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	next;
    old_pointer = @defined(@entry($arg1)) ?
			   @entry($arg1) : @entry(register("rdi"));
    new_pointer = @defined($return) ? $return : register("rax");
    new_size	= @defined(@entry($arg3)) ?
			   @entry($arg3) : @entry(register("rdx"));
    old_size	= @defined(@entry($arg2)) ?
			   @entry($arg2) : @entry(register("rsi"));
    common_mremap(new_pointer, old_pointer, new_size, old_size, n_mremap);
}

function common_munmap(pointer, size, kind) {
    check_signal();
    new_pointer = 0;
    new_size = 0;

    /* These usually should only happen in glibc code, possibly due to memory
     * mapped with a direct syscall during binary load, but can also happen
     * with other binaries, that change map base or truncate the map. */
    size = align_page_size(size);
    if (mmap_sizes[pointer] != size) {
	/* Move the map forward */
	if (mmap_sizes[pointer]) {
	    new_pointer = pointer + size;
	    new_size = mmap_sizes[pointer] - size;
	}
	else {
	    /* Truncate the map */
	    foreach (map in mmap_sizes) {
		end = map + mmap_sizes[map];
		if (pointer >= map && pointer < end) {
		    if (pointer + size == end) {
			new_pointer = map;
			new_size = size;
		    }
		    else {
			/* FIXME Should compute the split 2 maps */
			printf("Not computing holes in memory maps\n");
			print_ubacktrace();
		    }
		    break;
		}
	    }
	}
    }
    if (mmap_sizes[pointer]) {
	delete mmap_sizes[pointer];
	delete pointer_sizes[pointer];
	if (record_double_free)
	    pointer_release_address_in_code[pointer] = ucaller_address();
    }
    else
	handle_invalid(pointer);
    code_address = pointer_alloc_addresses_in_code[pointer];
    if (code_address) {
	handle_watch(code_address == watch_address,
		     pointer && pointer == watch_pointer);
	if (size) {
	    if (verbose)
		++count_freed_in_code_address[code_address];
	    bytes_alloced_in_code_address[code_address] -= size;
	    if (bytes_alloced_in_code_address[code_address] == 0)
		forget(code_address);
	}
	delete pointer_alloc_addresses_in_code[pointer];
    }
    if (new_pointer)
	common_mmap(new_pointer, new_size, kind);
}

probe process("/lib64/libc.so.6").function("munmap") {
    if (ignore_mmap || pid() != target() ||
	(ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	next;
    pointer = @defined($arg1) ? $arg1 : register("rdi");
    size = @defined($arg2) ? $arg2 : register("rsi");
    munmaps[tid()] = 1;
    common_munmap(pointer, size, n_mmap);
}

function common_malloc(pointer, size, kind) {
    if (pointer) {
	if (record_double_free)
	    delete pointer_release_address_in_code[pointer];
	if (size == 0)
	    handle_non_portable(pointer);
	code_address = uaddr();
	handle_watch(code_address == watch_address, pointer == watch_pointer);
	bytes_alloced_in_code_address[code_address] += size;
	pointer_alloc_addresses_in_code[pointer] = code_address;
	pointer_sizes[pointer] = size;
	if (verbose) {
	    allocs[code_address] = kind;
	    ++count_alloced_in_code_address[code_address];
	    if (verbose > 1) {
		code_probe_names[code_address] = probefunc();
		if (pointer >= break_start && pointer < break_end)
		    break_alloc += size;
	    }
	}
    }
    /* Do it in a single point. Only do explicitly on return probes if
    * common_malloc() is not called. */
    --doing_memory_allocation[tid()];
}

probe
process("/lib64/libc.so.6").function("malloc").return,
process("/lib64/libc.so.6").function("valloc").return,	/* deprecated */
process("/lib64/libc.so.6").function("pvalloc").return	/* deprecated */
{
    if (pid() != target() || news[tid()])
	next;
    pointer = @defined($return) ? $return : register("rax");
    size = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
    common_malloc(pointer, size, n_malloc);
}

probe process("/lib64/libc.so.6").function("calloc").return {
    if (pid() != target() || news[tid()])
	next;
    pointer = @defined($return) ? $return : register("rax");
    number  = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
    count   = @defined(@entry($arg2)) ? @entry($arg2) : @entry(register("rsi"));
    size = number * count;
    common_malloc(pointer, size, n_calloc);
}

function common_realloc(new_pointer, old_pointer, new_size, kind) {
    code_address = uaddr();
    old_code_address = pointer_alloc_addresses_in_code[old_pointer];
    if (old_code_address) {
	handle_watch(old_code_address == watch_address &&
		     old_code_address != code_address,
		     old_pointer && old_pointer != new_pointer &&
		     old_pointer == watch_pointer);
	delete pointer_alloc_addresses_in_code[old_code_address];
	old_size = pointer_sizes[old_pointer];
	delete pointer_sizes[old_pointer];
	bytes_alloced_in_code_address[old_code_address] -= old_size;
	if (verbose > 1 &&
	    old_pointer >= break_start && old_pointer < break_end)
	    break_alloc -= old_size;
	if (bytes_alloced_in_code_address[old_code_address] == 0)
	    forget(old_code_address);
	if (verbose)
	    ++count_freed_in_code_address[old_code_address];
    }
    // assume no overflow
    bytes_alloced_in_code_address[code_address] += new_size;
    if (new_pointer) {
	if (record_double_free)
	    delete pointer_release_address_in_code[new_pointer];
	if (new_size == 0)
	    handle_non_portable(new_pointer);
	handle_watch(code_address == watch_address,
		     new_pointer == watch_pointer);
	pointer_alloc_addresses_in_code[new_pointer] = code_address;
	pointer_sizes[new_pointer] = new_size;
	if (verbose) {
	    allocs[code_address] = kind;
	    ++count_alloced_in_code_address[code_address];
	    if (verbose > 1) {
		code_probe_names[code_address] = probefunc();
		if (new_pointer >= break_start && new_pointer < break_end)
		    break_alloc += new_size;
	    }
	}
    }
    /* Do it in a single point. Only do explicitly on return probes if
    * common_realloc() is not called. */
    --doing_memory_allocation[tid()];
}

probe process("/lib64/libc.so.6").function("realloc") {
    if (pid() != target() || news[tid()])
	next;
    check_signal();
    news[tid()] = 1;
    ++doing_memory_allocation[tid()];
}

probe process("/lib64/libc.so.6").function("realloc").return {
    if (pid() != target())
	next;
    new_pointer	= @defined($return) ? $return : register("rax");
    old_pointer = @defined(@entry($arg1)) ?
			   @entry($arg1) : @entry(register("rdi"));
    new_size	= @defined(@entry($arg2)) ?
			   @entry($arg2) : @entry(register("rsi"));
    common_realloc(new_pointer, old_pointer, new_size, n_realloc);
    delete news[tid()];
}

probe process("/lib64/libc.so.6").function("reallocarray").return {
    if (pid() != target())
	next;
    /* reallocarray checks for overflow and calls realloc.
     * Update the allocation kind. */
      if (verbose)
	  allocs[uaddr()] = n_reallocarray;
}

probe process("/lib64/libc.so.6").function("posix_memalign").return {
    if (pid() != target() || news[tid()])
	next;
    result = @defined($return) ? $return : register("rax");
    if (result == 0) {
	pointer_to_pointer = @defined(@entry($arg1)) ?
				      @entry($arg1) : register("rdi");
	size		   = @defined(@entry($arg3)) ?
				      @entry($arg3) : register("rdx");
	pointer = user_int64(pointer_to_pointer);
	common_malloc(pointer, size, n_posix_memalign);
    }
    else
	/* Make sure to have value synchronized, as it is decreased in
	 * common_malloc() */
	--doing_memory_allocation[tid()];
}

probe
process("/lib64/libc.so.6").function("aligned_alloc").return,
process("/lib64/libc.so.6").function("memalign").return	/* deprecated */
{
    if (pid() != target() || news[tid()])
	next;
    pointer = @defined($return) ? $return : register("rax");
    size    = @defined(@entry($arg2)) ?
		       @entry($arg2) : @entry(register("rsi"));
    common_malloc(pointer, size, n_aligned_alloc);
}

function common_free(pointer) {
    if (!pointer)
	return;
    size = pointer_sizes[pointer];
    delete pointer_sizes[pointer];
    code_address = pointer_alloc_addresses_in_code[pointer];
    if (code_address) {
	/* Should be invalid if attaching to process or something
	 * like an destructor after a dlclose call */
	handle_watch(code_address == watch_address,
		     pointer && pointer == watch_pointer);
	if (size) {
	    if (verbose) {
		++count_freed_in_code_address[code_address];
		if (verbose > 1 &&
		    pointer >= break_start && pointer < break_end)
		    break_alloc -= size;
	    }
	    bytes_alloced_in_code_address[code_address] -= size;
	    if (bytes_alloced_in_code_address[code_address] == 0)
		forget(code_address);
	}
	delete pointer_alloc_addresses_in_code[pointer];
	if (record_double_free)
	    pointer_release_address_in_code[pointer] = ucaller_address();
    }
    else
	handle_invalid(pointer);
}

probe process("/lib64/libc.so.6").function("free") {
    if (pid() != target() || deletes[tid()])
	next;
    check_signal();
    pointer = @defined($arg1) ? $arg1 : register("rdi");
    ++doing_memory_allocation[tid()];
    common_free(pointer);
}

probe process("/lib64/libc.so.6").function("free").return {
    if (pid() != target() || deletes[tid()])
	next;
    --doing_memory_allocation[tid()];
}

probe
/*
// operator new[](unsigned long, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZnamSt11align_val_t"),
// operator new(unsigned long, std::align_val_t, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZnwmSt11align_val_tRKSt9nothrow_t"),
// operator new(unsigned long, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZnwmRKSt9nothrow_t"),
// operator new[](unsigned long, std::align_val_t, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZnamSt11align_val_tRKSt9nothrow_t"),
// operator new[](unsigned long)
process("/lib64/libstdc++.so.6").function("_Znam"),
// operator new[](unsigned long, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZnamRKSt9nothrow_t"),
 */
// operator new(unsigned long, std::align_val_t) -- posix_memalign
process("/lib64/libstdc++.so.6").function("_ZnwmSt11align_val_t"),
// operator new(unsigned long) -- malloc
process("/lib64/libstdc++.so.6").function("_Znwm")
{
    if (pid() != target())
	next;
    check_signal();
    news[tid()] = 1;
    ++doing_memory_allocation[tid()];
}

probe
/*
process("/lib64/libstdc++.so.6").function("_ZnwmSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_ZnwmRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZnwmSt11align_val_tRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZnamSt11align_val_tRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_Znam").return,
process("/lib64/libstdc++.so.6").function("_ZnamRKSt9nothrow_t").return,
 */
process("/lib64/libstdc++.so.6").function("_ZnamSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_Znwm").return
{
    if (pid() != target())
	next;
    pointer = @defined($return) ? $return : register("rax");
    size    = @defined(@entry($arg1)) ?
		       @entry($arg1) : @entry(register("rdi"));
    common_malloc(pointer, size, n_new);
    delete news[tid()];
}

probe
/*
// operator delete(void*, std::align_val_t, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZdlPvSt11align_val_tRKSt9nothrow_t"),
// operator delete(void*, unsigned long)
process("/lib64/libstdc++.so.6").function("_ZdlPvm"),
// operator delete[](void*, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZdaPvRKSt9nothrow_t"),
// operator delete(void*, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZdlPvRKSt9nothrow_t"),
// operator delete[](void*, std::align_val_t, std::nothrow_t const&)
process("/lib64/libstdc++.so.6").function("_ZdaPvSt11align_val_tRKSt9nothrow_t"),
// operator delete(void*, unsigned long, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZdlPvmSt11align_val_t"),
// operator delete[](void*)
process("/lib64/libstdc++.so.6").function("_ZdaPv"),
// operator delete(void*, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZdlPvSt11align_val_t"),
// operator delete[](void*, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZdaPvSt11align_val_t"),
// operator delete[](void*, unsigned long)
process("/lib64/libstdc++.so.6").function("_ZdaPvm"),
// operator delete[](void*, unsigned long, std::align_val_t)
process("/lib64/libstdc++.so.6").function("_ZdaPvmSt11align_val_t"),
 */
// operator delete(void*) -- free
process("/lib64/libstdc++.so.6").function("_ZdlPv")
{
    if (pid() != target())
	next;
    check_signal();
    deletes[tid()] = 1;
    pointer = @defined($arg1) ? $arg1 : register("rdi");
    common_free(pointer);
    ++doing_memory_allocation[tid()];
}

probe
/*
process("/lib64/libstdc++.so.6").function("_ZdlPvSt11align_val_tRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZdlPvm").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZdlPvRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvSt11align_val_tRKSt9nothrow_t").return,
process("/lib64/libstdc++.so.6").function("_ZdlPvmSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_ZdaPv").return,
process("/lib64/libstdc++.so.6").function("_ZdlPvSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvSt11align_val_t").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvm").return,
process("/lib64/libstdc++.so.6").function("_ZdaPvmSt11align_val_t").return,
 */
process("/lib64/libstdc++.so.6").function("_ZdlPv").return
{
    if (pid() != target())
	next;
    delete deletes[tid()];
    --doing_memory_allocation[tid()];
}

%( 0 == 0 %?
  probe
  process("/lib64/libjemalloc.so.2").function("malloc") ?,
  process("/lib64/libjemalloc.so.2").function("mallocx") ?,
  process("/lib64/libjemalloc.so.2").function("calloc") ?,
  process("/lib64/libjemalloc.so.2").function("realloc") ?,
  process("/lib64/libjemalloc.so.2").function("rallocx") ?,
  process("/lib64/libjemalloc.so.2").function("posix_memalign") ?,
  process("/lib64/libjemalloc.so.2").function("aligned_alloc") ?
  {
      if (pid() != target())
	  next;
      check_signal();
      ++doing_memory_allocation[tid()];
  }

  probe
  process("/lib64/libjemalloc.so.2").function("malloc").return ?,
  process("/lib64/libjemalloc.so.2").function("mallocx").return ? /* Non standard */
  {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      size = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
      common_malloc(pointer, size, n_je_malloc);
  }

  probe process("/lib64/libjemalloc.so.2").function("calloc").return ? {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      number  = @defined(@entry($arg1)) ?
			 @entry($arg1) : @entry(register("rdi"));
      count   = @defined(@entry($arg2)) ?
			 @entry($arg2) : @entry(register("rsi"));
      size = number * count;
      common_malloc(pointer, size, n_je_calloc);
  }

  probe
  process("/lib64/libjemalloc.so.2").function("realloc").return ?,
  process("/lib64/libjemalloc.so.2").function("rallocx").return ? {
      if (pid() != target())
	  next;
      new_pointer	= @defined($return) ? $return : register("rax");
      old_pointer	= @defined(@entry($arg1)) ?
				   @entry($arg1) : @entry(register("rdi"));
      new_size		= @defined(@entry($arg2)) ?
				   @entry($arg2) : @entry(register("rsi"));
      common_realloc(new_pointer, old_pointer, new_size, n_je_realloc);
  }

  probe process("/lib64/libjemalloc.so.2").function("posix_memalign").return ? {
      if (pid() != target())
	  next;
      result = @defined($return) ? $return : register("rax");
      if (result == 0) {
	  pointer_to_pointer = @defined(@entry($arg1)) ?
					@entry($arg1) : register("rdi");
	  size		   = @defined(@entry($arg3)) ?
	  @entry($arg3) : register("rdx");
	  pointer = user_int64(pointer_to_pointer);
	  common_malloc(pointer, size, n_je_posix_memalign);
      }
      else
	  /* Make sure to have value synchronized, as it is decreased in
	   * common_malloc() */
	  --doing_memory_allocation[tid()];
  }

  probe
  process("/lib64/libjemalloc.so.2").function("aligned_alloc").return ? {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      size    = @defined(@entry($arg2)) ?
      @entry($arg2) : @entry(register("rsi"));
      common_malloc(pointer, size, n_je_aligned_alloc);
  }

  /* XXX Note that memory is not tagged by allocator. This might be done,
   * but if mixed allocators are used, it should crash and not worth the
   * work to detect this. */
  probe process("/lib64/libjemalloc.so.2").function("free") ? {
      if (pid() != target())
	  next;
      check_signal();
      pointer = @defined($arg1) ? $arg1 : register("rdi");
      common_free(pointer);
      ++doing_memory_allocation[tid()];
  }
  probe process("/lib64/libjemalloc.so.2").function("free").return ? {
      if (pid() != target())
	  next;
      --doing_memory_allocation[tid()];
  }
  %)

%( 1 == 1 %?
  probe
  process("/lib64/libtcmalloc*.so.4").function("sbrk") ?
  {
      if (pid() != target())
	  next;
      check_signal();
  }
  probe
  process("/lib64/libtcmalloc*.so.4").function("malloc") ?,
  process("/lib64/libtcmalloc*.so.4").function("calloc") ?,
  process("/lib64/libtcmalloc*.so.4").function("realloc") ?,
  process("/lib64/libtcmalloc*.so.4").function("posix_memalign") ?,
  process("/lib64/libtcmalloc*.so.4").function("aligned_alloc") ?
  {
      if (pid() != target())
	  next;
      check_signal();
      ++doing_memory_allocation[tid()];
  }

  probe process("/lib64/libtcmalloc*.so.4").function("sbrk").return ? {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      if (pointer != -1) {
	  handle_watch(uaddr() == watch_address,
		       pointer && pointer == watch_pointer);
	  /*
	    increment = @defined(@entry($arg1)) ?
				 @entry($arg1) : @entry(register("rdi"));
	 */
	  if (break_start == 0 || pointer < break_start)
	      break_start = pointer;
	  if (break_end == 0 || pointer > break_end)
	      break_end = pointer;
      }
  }

  /* Not called if preloading */
  probe process("/lib64/libctcmalloc*.so.4").function("mmap") ? {
      if (ignore_mmap || pid() != target() ||
	  (ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	  next;
      check_signal();
      mmaps[tid()] = 1;
  }
  probe process("/lib64/libtcmalloc*.so.4").function("mmap").return ? {
      if (ignore_mmap || pid() != target() ||
	  (ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	  next;
      pointer = @defined($return) ? $return : register("rax");
      if (pointer != -1) {
	  size = @defined(@entry($arg2)) ?
			  @entry($arg2) : @entry(register("rsi"));
	  common_mmap(pointer, size, n_tc_mmap);
      }
  }

  /* Not called if preloading? */
  probe process("/lib64/libtcmalloc*.so.4").function("mremap").return ? {
      if (ignore_mmap || pid() != target() ||
	  (ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	  next;
      old_pointer = @defined(@entry($arg1)) ?
			   @entry($arg1) : @entry(register("rdi"));
      new_pointer = @defined($return) ? $return : register("rax");
      new_size	  = @defined(@entry($arg3)) ?
			     @entry($arg3) : @entry(register("rdx"));
      old_size	  = @defined(@entry($arg2)) ?
			     @entry($arg2) : @entry(register("rsi"));
      common_mremap(new_pointer, old_pointer, new_size, old_size, n_tc_mremap);
  }

  probe process("/lib64/libctcmalloc*.so.4").function("munmap") ? {
      if (ignore_mmap || pid() != target() ||
	  (ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	  next;
      check_signal();
      munmaps[tid()] = 1;
  }
  probe process("/lib64/libtcmalloc*.so.4").function("munmap") ? {
      if (ignore_mmap || pid() != target() ||
	  (ignore_mmap_during_alloc && doing_memory_allocation[tid()]))
	  next;
      pointer = @defined($arg1) ? $arg1 : register("rdi");
      size = @defined($arg2) ? $arg2 : register("rsi");
      munmaps[tid()] = 1;
      common_munmap(pointer, size, n_tc_mmap);
  }

  probe
  process("/lib64/libtcmalloc*.so.4").function("malloc").return ?,
  process("/lib64/libtcmalloc*.so.4").function("valloc").return ?, /* deprecated */
  process("/lib64/libtcmalloc*.so.4").function("pvalloc").return ? /* deprecated */
  {
      if (pid() != target())
	  next;
      if (!tc_news[tid()]) {
	  pointer = @defined($return) ? $return : register("rax");
	  size = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
	  common_malloc(pointer, size, n_tc_malloc);
      }
      else
	  /* Make sure to have value synchronized, as it is decreased in
	   * common_malloc() */
	  --doing_memory_allocation[tid()];
  }

  probe process("/lib64/libtcmalloc*.so.4").function("calloc").return ? {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      number  = @defined(@entry($arg1)) ?
			 @entry($arg1) : @entry(register("rdi"));
      count   = @defined(@entry($arg2)) ?
			 @entry($arg2) : @entry(register("rsi"));
      size = number * count;
      common_malloc(pointer, size, n_tc_calloc);
  }

  probe process("/lib64/libtcmalloc*.so.4").function("realloc").return ? {
      if (pid() != target())
	  next;
      new_pointer	= @defined($return) ? $return : register("rax");
      old_pointer	= @defined(@entry($arg1)) ?
				   @entry($arg1) : @entry(register("rdi"));
      new_size		= @defined(@entry($arg2)) ?
				   @entry($arg2) : @entry(register("rsi"));
      common_realloc(new_pointer, old_pointer, new_size, n_tc_realloc);
  }

  probe process("/lib64/libtcmalloc*.so.4").function("posix_memalign").return ? {
      if (pid() != target())
	  next;
      result = @defined($return) ? $return : register("rax");
      if (result == 0) {
	  pointer_to_pointer = @defined(@entry($arg1)) ?
					@entry($arg1) : register("rdi");
	  size		   = @defined(@entry($arg3)) ?
	  @entry($arg3) : register("rdx");
	  pointer = user_int64(pointer_to_pointer);
	  common_malloc(pointer, size, n_tc_posix_memalign);
      }
      else
	  /* Make sure to have value synchronized, as it is decreased in
	   * common_malloc() */
	  --doing_memory_allocation[tid()];
  }

  probe
  process("/lib64/libtcmalloc*.so.4").function("aligned_alloc").return ?,
  process("/lib64/libtcmalloc*.so.4").function("memalign").return ? {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      size    = @defined(@entry($arg2)) ?
      @entry($arg2) : @entry(register("rsi"));
      common_malloc(pointer, size, n_tc_aligned_alloc);
  }

  probe process("/lib64/libtcmalloc*.so.4").function("free") ? {
      if (pid() != target())
	  next;
      ++doing_memory_allocation[tid()]
      if (!tc_deletes[tid()]) {
	  check_signal();
	  pointer = @defined($arg1) ? $arg1 : register("rdi");
	  common_free(pointer);
      }
  }
  probe process("/lib64/libtcmalloc*.so.4").function("free").return ? {
      if (pid() != target())
	  next;
      --doing_memory_allocation[tid()]
  }


  probe
  /*
  // operator new(unsigned long)
  process("/lib64/libtcmalloc*.so.4").function("_Znwm") ?,
 */
  // operator new[](unsigned long)
  process("/lib64/libtcmalloc*.so.4").function("_Znam") ?,
  /*
  // operator new(unsigned long, std::nothrow_t const&)
  process("/lib64/libtcmalloc*.so.4").function("_ZnwmRKSt9nothrow_t") ?,
  */
  // operator new[](unsigned long, std::nothrow_t const&)
  process("/lib64/libtcmalloc*.so.4").function("_ZnamRKSt9nothrow_t") ?,
  /*
  // operator new(unsigned long, std::align_val_t)
  process("/lib64/libtcmalloc*.so.4").function("_ZnwmSt11align_val_t") ?,
  */
  // operator new[](unsigned long, std::align_val_t)
  process("/lib64/libtcmalloc*.so.4").function("_ZnamSt11align_val_t") ?,
  /*
  // operator new(unsigned long, std::align_val_t, std::nothrow_t const&)
  process("/lib64/libtcmalloc*.so.4").function("_ZnwmSt11align_val_tRKSt9nothrow_t") ?,
  */
  // operator new[](unsigned long, std::align_val_t, std::nothrow_t const&)
  process("/lib64/libtcmalloc*.so.4").function("_ZnamSt11align_val_tRKSt9nothrow_t") ?
  {
      if (pid() != target())
	  next;
      if (tc_news[tid()]++ == 0) {
	  check_signal();
	  ++doing_memory_allocation[tid()];
      }
  }

  probe
  process("/lib64/libtcmalloc*.so.4").function("_Znam").return ?,
  process("/lib64/libtcmalloc*.so.4").function("_ZnamRKSt9nothrow_t").return ?,
  process("/lib64/libtcmalloc*.so.4").function("_ZnamSt11align_val_t").return ?,
  process("/lib64/libtcmalloc*.so.4").function("_ZnamSt11align_val_tRKSt9nothrow_t").return ?
  {
      if (pid() != target())
	  next;
      if (--tc_news[tid()] == 0) {
	  pointer = @defined($return) ? $return : register("rax");
	  size = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
	  common_malloc(pointer, size, n_tc_new);
      }
  }

  probe
  /*
  // operator delete(void*, std::nothrow_t const&)
  process("/lib64/libtcmalloc*.so.4").function("_ZdlPvRKSt9nothrow_t") ?,
  */
  // operator delete[](void*, std::nothrow_t const&)
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPvRKSt9nothrow_t") ?,
  /*
  // operator delete(void*, unsigned long)
  process("/lib64/libtcmalloc*.so.4").function("_ZdlPvm") ?,
  */
  // operator delete[](void*, unsigned long)
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPvm") ?,
  /*
  // operator delete(void*, std::align_val_t)
  process("/lib64/libtcmalloc*.so.4").function("_ZdlPvSt11align_val_t") ?,
  */
  // operator delete[](void*, std::align_val_t)
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPvSt11align_val_t") ?,
  /*
  // operator delete(void*, std::align_val_t, std::nothrow_t const&)
  process("/lib64/libtcmalloc*.so.4").function("_ZdlPvSt11align_val_tRKSt9nothrow_t") ?,
  */
  // operator delete[](void*, std::align_val_t, std::nothrow_t const&)
   process("/lib64/libtcmalloc*.so.4").function("_ZdaPvSt11align_val_tRKSt9nothrow_t") ?,
  /*
  // operator delete(void*, unsigned long, std::align_val_t)
  process("/lib64/libtcmalloc*.so.4").function("_ZdlPvmSt11align_val_t") ?,
  */
  // operator delete[](void*, unsigned long, std::align_val_t)
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPvmSt11align_val_t") ?,
  /*
  // operator delete(void*)
  process("/lib64/libtcmalloc*.so.4").function("_ZdlPv") ?,
 */
  // operator delete[](void*)
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPv") ?
  {
      if (pid() != target())
	  next;
      if (tc_deletes[tid()]++ == 0)
	  check_signal();
      ++doing_memory_allocation[tid()];
  }

  probe
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPvRKSt9nothrow_t").return ?,
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPvm").return ?,
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPvSt11align_val_t").return ?,
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPvSt11align_val_tRKSt9nothrow_t").return ?,
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPvmSt11align_val_t").return ?,
  process("/lib64/libtcmalloc*.so.4").function("_ZdaPv").return ?
  {
      if (pid() != target())
	  next;
      if (--tc_deletes[tid()] == 0) {
	  pointer = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
	  common_free(pointer);
      }
      --doing_memory_allocation[tid()];
  }
  %)

%( 2 == 2 /* mimalloc */ %?
  probe
  process("/lib64/libmimalloc*.so.2").function("malloc") ?,
  process("/lib64/libmimalloc*.so.2").function("calloc") ?,
  process("/lib64/libmimalloc*.so.2").function("realloc") ?,
  process("/lib64/libmimalloc*.so.2").function("reallocf") ?,
  process("/lib64/libmimalloc*.so.2").function("reallocarray") ?,
  process("/lib64/libmimalloc*.so.2").function("posix_memalign") ?,
  process("/lib64/libmimalloc*.so.2").function("aligned_alloc") ?,
  process("/lib64/libmimalloc*.so.2").function("strdup") ?,
  process("/lib64/libmimalloc*.so.2").function("strndup") ?
  {
      if (pid() != target())
	  next;
      check_signal();
      ++doing_memory_allocation[tid()];
  }

  probe
  process("/lib64/libmimalloc*.so.2").function("malloc").return ?,
  process("/lib64/libmimalloc*.so.2").function("valloc").return ?, /* deprecated */
  process("/lib64/libmimalloc*.so.2").function("pvalloc").return ? /* deprecated */
  {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      size = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
      common_malloc(pointer, size, n_mi_malloc);
  }

  probe process("/lib64/libmimalloc*.so.2").function("calloc").return ? {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      number  = @defined(@entry($arg1)) ?
			 @entry($arg1) : @entry(register("rdi"));
      count   = @defined(@entry($arg2)) ?
			 @entry($arg2) : @entry(register("rsi"));
      size = number * count;
      common_malloc(pointer, size, n_mi_calloc);
  }

  probe
  process("/lib64/libmimalloc*.so.2").function("realloc").return ?,
  process("/lib64/libmimalloc*.so.2").function("reallocf").return ? {
      if (pid() != target())
	  next;
      new_pointer	= @defined($return) ? $return : register("rax");
      old_pointer	= @defined(@entry($arg1)) ?
				   @entry($arg1) : @entry(register("rdi"));
      new_size		= @defined(@entry($arg2)) ?
				   @entry($arg2) : @entry(register("rsi"));
      common_realloc(new_pointer, old_pointer, new_size, n_mi_realloc);
  }

  probe process("/lib64/libmimalloc*.so.2").function("reallocarray").return ? {
      if (pid() != target())
	  next;
      new_pointer	= @defined($return) ? $return : register("rax");
      old_pointer	= @defined(@entry($arg1)) ?
				   @entry($arg1) : @entry(register("rdi"));
      nmemb		= @defined(@entry($arg2)) ?
				   @entry($arg2) : @entry(register("rsi"));
      size		= @defined(@entry($arg3)) ?
				   @entry($arg3) : @entry(register("rdx"));
      /* ignore overflow as it should have been handled in error path */
      new_size = nmemb * size;
      common_realloc(new_pointer, old_pointer, new_size, n_mi_reallocarray);
  }

  probe process("/lib64/libmimalloc*.so.2").function("posix_memalign").return ? {
      if (pid() != target())
	  next;
      result = @defined($return) ? $return : register("rax");
      if (result == 0) {
	  pointer_to_pointer = @defined(@entry($arg1)) ?
					@entry($arg1) : register("rdi");
	  size		   = @defined(@entry($arg3)) ?
	  @entry($arg3) : register("rdx");
	  pointer = user_int64(pointer_to_pointer);
	  common_malloc(pointer, size, n_mi_posix_memalign);
      }
      else
	  /* Make sure to have value synchronized, as it is decreased in
	   * common_malloc() */
	  --doing_memory_allocation[tid()];
  }

  probe
  process("/lib64/libmimalloc*.so.2").function("aligned_alloc").return ?,
  process("/lib64/libmimalloc*.so.2").function("memalign").return ? {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      size    = @defined(@entry($arg2)) ?
      @entry($arg2) : @entry(register("rsi"));
      common_malloc(pointer, size, n_mi_aligned_alloc);
  }

  probe
  process("/lib64/libmimalloc*.so.2").function("strdup").return ?,
  process("/lib64/libmimalloc*.so.2").function("strndup").return ? {
    if (pid() != target())
	next;
    pointer = @defined($return) ? $return : register("rax");
    if (pointer) {
	str = user_string(pointer);
	size = strlen(str) + 1;
	common_malloc(pointer, size, n_mi_strdup);
    }
    else
	/* Make sure to have value synchronized, as it is decreased in
	 * common_malloc() */
	--doing_memory_allocation[tid()];
  }

  probe process("/lib64/libmimalloc*.so.2").function("free") ? {
      if (pid() != target())
	  next;
      ++doing_memory_allocation[tid()]
      if (!mi_deletes[tid()]) {
	  check_signal();
	  pointer = @defined($arg1) ? $arg1 : register("rdi");
	  common_free(pointer);
      }
  }
  probe process("/lib64/libmimalloc*.so.2").function("free").return ? {
      if (pid() != target())
	  next;
      --doing_memory_allocation[tid()]
  }


  probe
  /*
  // operator new(unsigned long)
  process("/lib64/libmimalloc*.so.2").function("_Znwm") ?,
 */
  // operator new[](unsigned long)
  process("/lib64/libmimalloc*.so.2").function("_Znam") ?,
  /*
  // operator new(unsigned long, std::nothrow_t const&)
  process("/lib64/libmimalloc*.so.2").function("_ZnwmRKSt9nothrow_t") ?,
  */
  // operator new[](unsigned long, std::nothrow_t const&)
  process("/lib64/libmimalloc*.so.2").function("_ZnamRKSt9nothrow_t") ?,
  /*
  // operator new(unsigned long, std::align_val_t)
  process("/lib64/libmimalloc*.so.2").function("_ZnwmSt11align_val_t") ?,
  */
  // operator new[](unsigned long, std::align_val_t)
  process("/lib64/libmimalloc*.so.2").function("_ZnamSt11align_val_t") ?,
  /*
  // operator new(unsigned long, std::align_val_t, std::nothrow_t const&)
  process("/lib64/libmimalloc*.so.2").function("_ZnwmSt11align_val_tRKSt9nothrow_t") ?,
  */
  // operator new[](unsigned long, std::align_val_t, std::nothrow_t const&)
  process("/lib64/libmimalloc*.so.2").function("_ZnamSt11align_val_tRKSt9nothrow_t") ?
  {
      if (pid() != target())
	  next;
      check_signal();
      ++doing_memory_allocation[tid()];
  }

  probe
  process("/lib64/libmimalloc*.so.2").function("_Znam").return ?,
  process("/lib64/libmimalloc*.so.2").function("_ZnamRKSt9nothrow_t").return ?,
  process("/lib64/libmimalloc*.so.2").function("_ZnamSt11align_val_t").return ?,
  process("/lib64/libmimalloc*.so.2").function("_ZnamSt11align_val_tRKSt9nothrow_t").return ?
  {
      if (pid() != target())
	  next;
      pointer = @defined($return) ? $return : register("rax");
      size = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
      common_malloc(pointer, size, n_mi_new);
  }

  probe
  /*
  // operator delete(void*, std::nothrow_t const&)
  process("/lib64/libmimalloc*.so.2").function("_ZdlPvRKSt9nothrow_t") ?,
  */
  // operator delete[](void*, std::nothrow_t const&)
  process("/lib64/libmimalloc*.so.2").function("_ZdaPvRKSt9nothrow_t") ?,
  /*
  // operator delete(void*, unsigned long)
  process("/lib64/libmimalloc*.so.2").function("_ZdlPvm") ?,
  */
  // operator delete[](void*, unsigned long)
  process("/lib64/libmimalloc*.so.2").function("_ZdaPvm") ?,
  /*
  // operator delete(void*, std::align_val_t)
  process("/lib64/libmimalloc*.so.2").function("_ZdlPvSt11align_val_t") ?,
  */
  // operator delete[](void*, std::align_val_t)
  process("/lib64/libmimalloc*.so.2").function("_ZdaPvSt11align_val_t") ?,
  /*
  // operator delete(void*, std::align_val_t, std::nothrow_t const&)
  process("/lib64/libmimalloc*.so.2").function("_ZdlPvSt11align_val_tRKSt9nothrow_t") ?,
  */
  // operator delete[](void*, std::align_val_t, std::nothrow_t const&)
   process("/lib64/libmimalloc*.so.2").function("_ZdaPvSt11align_val_tRKSt9nothrow_t") ?,
  /*
  // operator delete(void*, unsigned long, std::align_val_t)
  process("/lib64/libmimalloc*.so.2").function("_ZdlPvmSt11align_val_t") ?,
  */
  // operator delete[](void*, unsigned long, std::align_val_t)
  process("/lib64/libmimalloc*.so.2").function("_ZdaPvmSt11align_val_t") ?,
  /*
  // operator delete(void*)
  process("/lib64/libmimalloc*.so.2").function("_ZdlPv") ?,
 */
  // operator delete[](void*)
  process("/lib64/libmimalloc*.so.2").function("_ZdaPv") ?
  {
      if (pid() != target())
	  next;
      if (mi_deletes[tid()]++ == 0)
	  check_signal();
      ++doing_memory_allocation[tid()];
  }

  probe
  process("/lib64/libmimalloc*.so.2").function("_ZdaPvRKSt9nothrow_t").return ?,
  process("/lib64/libmimalloc*.so.2").function("_ZdaPvm").return ?,
  process("/lib64/libmimalloc*.so.2").function("_ZdaPvSt11align_val_t").return ?,
  process("/lib64/libmimalloc*.so.2").function("_ZdaPvSt11align_val_tRKSt9nothrow_t").return ?,
  process("/lib64/libmimalloc*.so.2").function("_ZdaPvmSt11align_val_t").return ?,
  process("/lib64/libmimalloc*.so.2").function("_ZdaPv").return ?
  {
      if (pid() != target())
	  next;
      if (--mi_deletes[tid()] == 0) {
	  pointer = @defined(@entry($arg1)) ? @entry($arg1) : @entry(register("rdi"));
	  common_free(pointer);
      }
      --doing_memory_allocation[tid()];
  }
  %)

function allocator:string(address:long) {
    value = allocs[address];
    if (value == n_syscall)		return "syscall";
    if (value == n_mmap)		return "mmap";
    if (value == n_mremap)		return "mremap";
    if (value == n_malloc)		return "malloc";
    if (value == n_calloc)		return "calloc";
    if (value == n_realloc)		return "realloc";
    if (value == n_reallocarray)	return "reallocarray";
    if (value == n_posix_memalign)	return "posix_memalign";
    if (value == n_aligned_alloc)	return "aligned_alloc";
    if (value == n_new)			return "operator new";
     %( 0 == 0 /* jemalloc */ %?
      if (value == n_je_malloc)	return "je_malloc";
      if (value == n_je_calloc)	return "je_malloc";
      if (value == n_je_realloc)	return "je_realloc";
      if (value == n_je_posix_memalign)return "je_posix_memalign";
      if (value == n_je_aligned_alloc)	return "je_aligned_alloc";
      %)
     %( 1 == 1 /* tcmalloc */ %?
      if (value == n_tc_malloc)		return "tc_malloc";
      if (value == n_tc_calloc)		return "tc_calloc";
      if (value == n_tc_realloc)	return "tc_realloc";
      if (value == n_tc_posix_memalign)	return "tc_posix_memalign";
      if (value == n_tc_aligned_alloc)	return "tc_aligned_alloc";
      if (value == n_tc_new)		return "tc operator new";
      %)
    %( 2 == 2 /* mimalloc */ %?
      if (value == n_mi_malloc)		return "mi_malloc";
      if (value == n_mi_calloc)		return "mi_calloc";
      if (value == n_mi_realloc)	return "mi_realloc";
      if (value == n_mi_reallocarray)	return "mi_reallocarray";
      if (value == n_mi_posix_memalign)	return "mi_posix_memalign";
      if (value == n_mi_aligned_alloc)	return "mi_aligned_alloc";
      if (value == n_mi_strdup)		return "mi_strdup";
      if (value == n_mi_new)		return "mi operator new";
      %)
    return "???";
}

/* Note that what is listed are not leaks, but allocated memory, that
 * could/should be reachable. */
function report() {
    total = 0;
    total_nomap = 0;
    break_range = break_end - break_start;
    printf("\nReport for %s (%s)\n", process_name, process_arguments);
    if (verbose) {
	if (verbose > 2) {
	    foreach (pointer in pointer_alloc_addresses_in_code)
		detailed_report[pointer_alloc_addresses_in_code[pointer]] .=
		    sprintf(" %p(%d)", pointer, pointer_sizes[pointer]);
	}
	printf("%16s\t      Count     \t%-16s\t%s\n", "Size", "Allocator", "Code Address");
	printf("------------------------------------------------------------------------------------------------\n");
	foreach (address in bytes_alloced_in_code_address) {
	    bytes = bytes_alloced_in_code_address[address];
	    total += bytes;
	    if (verbose > 1 &&
		allocs[address] != n_mmap &&
		allocs[address] != n_mremap)
		total_nomap += bytes;
	    printf("%16ld\t%8d-%-8d\t%-16s\t%s",
		   bytes,
		   count_alloced_in_code_address[address],
		   count_freed_in_code_address[address],
		   allocator(address),
		   usymfileline(address));
	    /* do not print address twice */
	    if (verbose > 1) {
		if (!strtol(code_probe_names[address], 16))
		    printf(" (%s)", code_probe_names[address]);
		else
		    printf("  - ");
		if (verbose > 2) {
		    printf("%s", detailed_report[address]);
		    length = strlen(detailed_report[address]);
		    detailed_report[address] .= " ";
		    if (length == strlen(detailed_report[address])) {
			string_truncate_length = length + 1;
			printf("...");
		    }
		    delete detailed_report[address];
		}
	    }
	    printf("\n");
	}
    }
    else {
	printf("%16s\t%s\n", "Size", "Code Address");
	printf("------------------------------------------------\n");
	foreach (address in bytes_alloced_in_code_address) {
	    bytes = bytes_alloced_in_code_address[address];
	    total += bytes;
	    printf("%16ld\t%s\n", bytes, usymfileline(address));
	}
    }
    /*   Bogus total is bogus amount of memory not released - it is bogus
     * because does not account for alignment, nor if the memory is from
     * mmap or the main arena.
     *   It also does not qualify as leaks at exit, as the memory might
     * be reachable. */
    printf("Bogus Total %54ld (%16p)\n", total, total);
    printf("Bogus Break [%-16p-%16p] = %16ld (%16p)\n", break_start, break_end,
	   break_range, break_range);
    if (verbose > 1) {
	printf("Bogus Heap  %54ld (%16p)\n", break_alloc, break_alloc);
	printf("Bogus NoMap %54ld (%16p)\n", total_nomap, total_nomap);
    }
}

probe signal.send {
    if (sig_name == "SIGURG" && sig_pid == target())
	report();
}

probe signal.handle {
    if (pid() != target() || sig_name == "SIGTRAP" ||
	sig_name == "SIGSTOP" || sig_name == "SIGTSTP")
	next;
    handling_signal = sig;
}

probe process("/lib64/libc.so.6").function("__restore_rt") {
    if (pid() != target())
	next;
    handling_signal = 0;
}

function reset() {
    delete pointer_alloc_addresses_in_code;
    if (record_double_free)
	delete pointer_release_address_in_code;
    delete pointer_sizes;
    delete mmap_sizes;
    if (verbose) {
	delete bytes_alloced_in_code_address;
	delete count_alloced_in_code_address;
	delete count_freed_in_code_address;
	delete code_probe_names;
	delete allocs;
	if (verbose > 1) {
	    delete code_probe_names;
	    /* Should be empty or only include entries where
	     * bytes_alloced_in_code_address[detailed_report[address]] == 0 */
	    if (verbose > 2)
		delete detailed_report;
	}
    }
    break_start = break_end = break_alloc = 0;

}

probe kprocess.exec {
    if (pid() != target())
	next;
    process_path = filename;
    exec_process_arguments = argstr;
}

probe kprocess.exec_complete {
    if (pid() != target())
	next;
    if (success) {
	if (process_name != "") {
	    report();
	    reset();
	}
	/* Uncomment for debugging start of gdbserver */
	/*
	if (start_gdbserver) {
	    printf("attached = %d\nbinary_path_for_gdbserver = %s\nprocess_path = %s\n",
		   attached, binary_path_for_gdbserver, process_path);
	}
	*/
	if (start_gdbserver && !attached &&
	    ((binary_path_for_gdbserver != "" &&
	      (binary_path_for_gdbserver == process_path ||
	       /* process_path is a string starting/ending with quotes */
	       sprintf("\"%s\"", binary_path_for_gdbserver) == process_path ||
	       /* Extra heuristic to match "/bin/foo" in "/usr/bin/foo"
		* and simplify the logic to "work as intended" */
	       isinstr(process_path, binary_path_for_gdbserver))) ||
	     (binary_path_for_gdbserver == "" && process_path != "")))
	    run_gdbserver(pid());
	process_name = execname();
	process_arguments = exec_process_arguments;
    }
}

probe end {
    report();
    if (verbose > 2 && string_truncate_length)
	printf("There were truncated reports (ending with ...). Rerun with -DMAXSTRINGLEN=N with N larger than %ld for more data.\n",
	       string_truncate_length);
    printf("Stap done.\n");
    reset();
}
